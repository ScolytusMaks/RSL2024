class inherited РКП_СИС.редОтчетОРаботеБазовый "Сводный отчет по вводу данных", editor ПротоколВводаГЛГС;

import РКП_СИС classes StdCode, Recs, Functions, FilterMaker, Def, StringsFunctions;

inobject private

--{{ 2_Свойства

  var Интерфейс :РКП_Статьи.RI.ПротоколВводаГЛГС;

  var КомпетенцииВОтчете :tCompetence[] := [кмпГЛГСзав, кмпГЛГСсотр];

--}}

-- 2_Конструкторы, визуализаторы0. --

inclass public

inobject private

-- 2_Обработчики событий шаблона0. --


-- 2_Обработчики событий клеток шаблона0. --

  func Поле_ПриВыводе_ЗаголовокОкнаФормы(Cell :TemplateCell; Value :Variant; Action :Template.OutputTypes; var Format :String) :Variant;
    Result = 'Протокол ввода данных группы ЛГС' + Br +
             '№ ' + Str(НомерОтчета) + ' / ' + Str(ЗаГод) + Br +
             '<s-><s->за период с ' + Str(ДатаН) + ' по  ' + Str(ДатаК) + ' включительно';
  end;


-- 2_Обработчики событий прочих объектов шаблона0. --


-- 2_Дополнительные команды0. --


-- 2_Вспомогательные методы0. --

  proc НовыйНомер;
    if (Self.Record.State = Kernel.Record.Created) then
      ЗаГод = Year(today);
      with Query.Create([РКП_Статьи.ПротоколВводаГЛГС]) do
        Filter = 'ЗаГод=' + Str(Year(today)) +' and DocID<>' + Str(Record.DocID);
        Order  = 'НомерОтчета-';
        Select;
        if not (RecordsExists) then
          НомерОтчета = 1;
        else
          НомерОтчета = (Current.НомерОтчета + 1);
        fi;
      end;
    fi;
  end;


  func ПостроитьОтчет :Logical;
    var aUserName :String[];
    var aUserFullName :String[2];
    var aResult :Variant[2];
    var i :Integer;
    Result = inherited ПостроитьОтчет;
    if Result then
      Статьи.Clear;
      ВсегоВведеноСтатей           = nil;
      ВсегоРедактированоСтатей     = nil;
      aUserFullName = ПолучитьПолныеИменаПользователей;
      aUserName = ПолучитьИменаПользователей('Роспись');
      if (aUserName <> nil) then
        aResult = ПолучитьВыборку(aUserName, 'Роспись');
        РасшифроватьИмена(aResult, aUserFullName);
        for i = 1 .. LengthOfArray(aResult) do
          with Self.Record.Статьи.AddEx do
            ОператорИмя   = aResult[i,1] as String;
            Оператор      = aResult[i,2] as String;
            Введено       = aResult[i,3] as Integer;
            Редактировано = aResult[i,4] as Integer;
            ВсегоВведеноСтатей       = ВсегоВведеноСтатей       + aResult[i,3] as Integer;
            ВсегоРедактированоСтатей = ВсегоРедактированоСтатей + aResult[i,4] as Integer;
          end;
        od;
      fi;
    fi;
  end;

  func ПолучитьИменаПользователей( КорИмяКлассаЗаписей :String ) :String[];
    var QResult :Variant[2];
    with Query.Create([РКП_СИС.ЛогРабот]) do
      Filter = ПолучитьФильтрЗапросаЛога(КорИмяКлассаЗаписей);
      QResult = CalcAggregates('GroupBy(CreateUser)') as Variant[2];
    end;
    if (QResult <> nil) then
      Result = QResult[1] as String[];
      SortArray(Result);
    fi;
  end;

  func ПолучитьПолныеИменаПользователей :String[2];
    var cResult :String[];
    with Query.Create([Kernel.Settings.User]) do
      Filter = 'isGroup=0';
      Select;
      while not Eof do
        cResult = [Current.Name, Current.FullName] as String[];
        AddInArray( Result, cResult);
        Next;
      od;
    end;
    SortArray(Result, [1]);
  end;

  func ПолучитьФильтрЗапросаЛога( КорИмяКлассаЗаписей :String ) :String;
    var aFlt :String[];
    AddInArray( aFlt, ПолучитьФильтрКомпетенций );
    AddInArray( aFlt, ПолучитьФильтрДат );
    AddInArray( aFlt, ПолучитьФильтрКлассаЗаписей(КорИмяКлассаЗаписей) );
    Result = MakeFilter( aFlt );
  end;

  func ПолучитьФильтрКомпетенций :String;
    var i :Integer;
    var aFlt :String[];
    for i = 1 .. LengthOfArray(КомпетенцииВОтчете) do
      AddInArray( aFlt, 'Match(Competencies, "*|' + Str(КомпетенцииВОтчете[i]) + '|*")' );
    od;
    Result = MakeFilter( aFlt, byOr );
  end;

  func ПолучитьФильтрДат :String;
    var aFlt :String[];
    AddInArray( aFlt, 'CreateDate>=' + Str(ДатаН) );
    AddInArray( aFlt, 'CreateDate<' + Str(ДатаК + 1) );
    Result = MakeFilter( aFlt );
  end;

  func ПолучитьФильтрКлассаЗаписей( КорИмяКлассаЗаписей :String ) :String;
    if (КорИмяКлассаЗаписей = 'Роспись') then
      Result =  'RClass="РКП_Статьи.Роспись"';
    fi;
  end;

  func ПолучитьВыборку(aUserName :String[]; КорИмяКлассаЗаписей :String ) :Variant[2];  --[[UserName, nil, vCreateCount, vUpdateCount]]
    var vCreateCount, vUpdateCount :Integer;
    var cResult :Variant[];
    var cRec :РКП_СИС.ЛогРабот;
    var i :Integer;
    if (aUserName <> nil) then
      with Query.Create([РКП_СИС.ЛогРабот]) do
        Filter = ПолучитьФильтрЗапросаЛога(КорИмяКлассаЗаписей);
        Select;
        while not Eof do
          cRec = Current as РКП_СИС.ЛогРабот;
          i = SearchInArray(aUserName, cRec.CreateUser,,true);
          if (i > 0) then
            cResult = Result[i] as Variant[];
            vCreateCount = cResult[3] as Integer;
            vUpdateCount = cResult[4] as Integer;
            if (cRec.ActionType = 0) then
              vCreateCount = vCreateCount + 1;
            elsif (cRec.ActionType = 1) then
              vUpdateCount = vUpdateCount + 1;
            fi;
            cResult = [aUserName[i],nil,vCreateCount, vUpdateCount];
            Result[i] = cResult;
          fi;
          Next;
        od;
      end;
    end;
  end;

  proc РасшифроватьИмена(var aResult :Variant[2]; aUserFullName :String[2]);
    var vUserFullName :String;
    var i, j :Integer;
    for i = 1 .. LengthOfArray(aResult) do
      j = SearchInArray(aUserFullName, aResult[i,1] as String, [1], true);
      if (j > 0) then
        vUserFullName = aUserFullName[j,2];
      fi;
      if (vUserFullName <> nil) then
        aResult[i]  = [aResult[i,1], vUserFullName, aResult[i,3], aResult[i,4]];
      else
        aResult[i]  = [aResult[i,1], aResult[i,1], aResult[i,3], aResult[i,4]];
      fi;
    od;
  end;


end