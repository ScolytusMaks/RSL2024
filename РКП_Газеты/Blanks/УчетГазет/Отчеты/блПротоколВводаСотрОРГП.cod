class inherited РКП_СИС.блОтчетОРаботеБазовый "Отчет о работе библиографа (ОРГП)";

import РКП_СИС classes StdCode, Recs, Functions, FilterMaker, Def, StringsFunctions, RI.intBase;

--{{ 2_Свойства

inobject private

  var КомпетенцииВОтчете :tCompetence[] := [кмпОРГПзав, кмпОРГПсотр];

  var НомерСменыГаз        :Integer[];
  var ДатаСменыГаз         :Date[];
  var ПринятоГазет         :Integer[];
  var ВсегоВведеноГазет    :Integer;

  var НомерСменыНом        :Integer[];
  var ДатаСменыНом         :Date[];
  var ПринятоНомеров       :Integer[];
  var ВсегоВведеноНомеров  :Integer;

  var НомерСменыЕдХрн      :Integer[];
  var ДатаСменыЕдХрн       :Date[];
  var ПринятоЕдХрн         :Integer[];
  var ВсегоВведеноЕдХрн    :Integer;

  var НомерСменыУчДок      :Integer[];
  var ДатаСменыУчДок       :Date[];
  var ПринятоУчДок         :Integer[];
  var ВсегоВведеноУчДок    :Integer;

  var секцГазеты           :TemplateSection;
  var секцНомера           :TemplateSection;
  var секцЕдХрн            :TemplateSection;
  var секцУчДок            :TemplateSection;

  var Сотрудник synonym UserName :String := SessionInfo.UserName;
  var СотрудникПолнИмя           :String := if((SessionInfo.UserRecord <> nil), (SessionInfo.UserRecord as Kernel.Settings.User).FullName, Self.UserName);

--}}

-- 2_Конструкторы, визуализаторы0. --

inclass public



inobject private

-- 2_Обработчики событий шаблона0. --

  proc шаблон_ПриОткрытии(Create :Logical);
    inherited шаблон_ПриОткрытии(Create);
    ПостроитьОтчет;
  end;


-- 2_Обработчики событий клеток шаблона0. --

  func Поле_ПриВыводе_ЗаголовокОкнаФормы(Cell :TemplateCell; Value :Variant; Action :Template.OutputTypes; var Format :String) :Variant;
    Result = 'Протокол ввода данных сотрудника' + Br +
             СотрудникПолнИмя + Br +
             '<s-><s->за период с ' + Str(ДатаН) + ' по  ' + Str(ДатаК) + ' включительно';
  end;


-- 2_Обработчики событий прочих объектов шаблона0. --


-- 2_Дополнительные команды0. --


-- 2_Вспомогательные методы0. --

  func ПостроитьОтчет :Logical;
    var aUserName :String[];
    var aResult :Variant[2]; --[[UserName, FullName, vCreateCount, vUpdateCount]]
    var aWorkShift :Variant[2]; -- номера смен [[vDate, vNumber]]
    var i :Integer;
    Result = inherited ПостроитьОтчет;
    if Result then
      НомерСменыГаз          = nil; НомерСменыНом          = nil; НомерСменыЕдХрн        = nil;  НомерСменыУчДок        = nil;
      ДатаСменыГаз           = nil; ДатаСменыНом           = nil; ДатаСменыЕдХрн         = nil;  ДатаСменыУчДок         = nil;
      ПринятоГазет           = nil; ПринятоНомеров         = nil; ПринятоЕдХрн           = nil;  ПринятоУчДок           = nil;
      ВсегоВведеноГазет      = nil; ВсегоВведеноНомеров    = nil; ВсегоВведеноЕдХрн      = nil;  ВсегоВведеноУчДок      = nil;
      секцГазеты.FramesCount = nil; секцНомера.FramesCount = nil; секцЕдХрн.FramesCount  = nil;  секцУчДок.FramesCount  = nil;
      if (Self.UserName <> nil) then
        aWorkShift = ПолучитьНомераСмен;
        --
        aResult = ПолучитьВыборку(aUserName, 'Газета');
        ПроставитьНомераСмен(aResult, aWorkShift);
        for i = 1 .. LengthOfArray(aResult) do
          НомерСменыГаз[i]  = aResult[i,2] as Integer;
          ДатаСменыГаз[i]   = aResult[i,1] as Date;
          ПринятоГазет[i]   = aResult[i,3] as Integer;
          ВсегоВведеноГазет = ВсегоВведеноГазет + ПринятоГазет[i];
        od;
        секцГазеты.FramesCount = LengthOfArray(aResult);
        --
        aResult = ПолучитьВыборку(aUserName, 'НомерГазеты');
        ПроставитьНомераСмен(aResult, aWorkShift);
        for i = 1 .. LengthOfArray(aResult) do
          НомерСменыНом[i]    = aResult[i,2] as Integer;
          ДатаСменыНом[i]     = aResult[i,1] as Date;
          ПринятоНомеров[i]   = aResult[i,3] as Integer;
          ВсегоВведеноНомеров = ВсегоВведеноНомеров + ПринятоНомеров[i];
        od;
        секцНомера.FramesCount = LengthOfArray(aResult);
        --
        aResult = ПолучитьВыборку(aUserName, 'ЕдиницаХранения');
        ПроставитьНомераСмен(aResult, aWorkShift);
        for i = 1 .. LengthOfArray(aResult) do
          НомерСменыЕдХрн[i] = aResult[i,2] as Integer;
          ДатаСменыЕдХрн[i]  = aResult[i,1] as Date;
          ПринятоЕдХрн[i]    = aResult[i,3] as Integer;
          ВсегоВведеноЕдХрн  = ВсегоВведеноЕдХрн + ПринятоЕдХрн[i];
        od;
        секцЕдХрн.FramesCount = LengthOfArray(aResult);
        --
        aResult = ПолучитьВыборку(aUserName, 'УчетныйДокумент');
        ПроставитьНомераСмен(aResult, aWorkShift);
        for i = 1 .. LengthOfArray(aResult) do
          НомерСменыУчДок[i] = aResult[i,2] as Integer;
          ДатаСменыУчДок[i]  = aResult[i,1] as Date;
          ПринятоУчДок[i]    = aResult[i,3] as Integer;
          ВсегоВведеноУчДок  = ВсегоВведеноУчДок + ПринятоУчДок[i];
        od;
        секцУчДок.FramesCount = LengthOfArray(aResult);
      fi;
    fi;
  end;

  func ПолучитьНомераСмен :Variant[2]; --[[vDate, vNumber]]
    var aFlt :String[];
    var cResult :Variant[];
    var cRec :РКП_СИС.Смена;
    var vActionDate  :Date;
    with Query.Create([РКП_СИС.Смена]) do
      AddInArray( aFlt, ПолучитьФильтрДат );
      AddInArray( aFlt, ПолучитьФильтрПользователя );
      Filter = MakeFilter(aFlt);
      Select;
      while not Eof do
        cRec = Current as РКП_СИС.Смена;
        vActionDate = cRec.CreateDate;
        vActionDate = Dat(Day(vActionDate), Mon(vActionDate), Year(vActionDate));
        cResult = [vActionDate, cRec.НомерСменыВГоду] as Variant[];
        AddInArray( Result, cResult);
        Next;
      od;
    end;
    SortArray(Result, [1]);
  end;

  func ПолучитьФильтрЗапросаЛога( КорИмяКлассаЗаписей :String ) :String;
    var aFlt :String[];
    AddInArray( aFlt, ПолучитьФильтрПользователя );
    AddInArray( aFlt, ПолучитьФильтрКомпетенций );
    AddInArray( aFlt, ПолучитьФильтрДат );
    AddInArray( aFlt, ПолучитьФильтрКлассаЗаписей(КорИмяКлассаЗаписей) );
    Result = MakeFilter( aFlt );
  end;

  func ПолучитьФильтрКомпетенций :String;
    var i :Integer;
    var aFlt :String[];
    for i = 1 .. LengthOfArray(КомпетенцииВОтчете) do
      AddInArray( aFlt, 'Match(Competencies, "*|' + Str(КомпетенцииВОтчете[i]) + '|*")' );
    od;
    Result = MakeFilter( aFlt, byOr );
  end;

  func ПолучитьФильтрДат :String;
    var aFlt :String[];
    AddInArray( aFlt, 'CreateDate>=' + Str(ДатаН) );
    AddInArray( aFlt, 'CreateDate<' + Str(ДатаК + 1) );
    Result = MakeFilter( aFlt );
  end;

  func ПолучитьФильтрПользователя :String;
    Return 'CreateUser="' + Self.UserName + '"';
  end;

  func ПолучитьФильтрКлассаЗаписей( КорИмяКлассаЗаписей :String ) :String;
    if (КорИмяКлассаЗаписей = 'Газета')             then Result = 'RClass="РКП_Газеты.Газета"';
    elsif (КорИмяКлассаЗаписей = 'НомерГазеты')     then Result = 'RClass="РКП_Газеты.НомерГазеты"';
    elsif (КорИмяКлассаЗаписей = 'ЕдиницаХранения') then Result = 'RClass="РКП_Газеты.ЕдиницаХранения"';
    elsif (КорИмяКлассаЗаписей = 'УчетныйДокумент') then Result = 'RClass="РКП_Газеты.УчетныйДокумент"';
    fi;
  end;

  func ПолучитьВыборку(aUserName :String[]; КорИмяКлассаЗаписей :String ) :Variant[2];  --[[vActionDate, nil, vCreateCount]]
    var vActionDate  :Date;
    var vCreateCount, i :Integer;
    var cResult :Variant[];
    var cRec :РКП_СИС.ЛогРабот;
    var rNsp :РКП_Газеты.Газета;
    if (Self.UserName <> nil) then
      with Query.Create([РКП_СИС.ЛогРабот]) do
        Filter = ПолучитьФильтрЗапросаЛога(КорИмяКлассаЗаписей);
        Select;
        while not Eof do
          cRec = Current as РКП_СИС.ЛогРабот;
          vActionDate = cRec.CreateDate;
          vActionDate = Dat(Day(vActionDate), Mon(vActionDate), Year(vActionDate));
          i = SearchInArray(Result, vActionDate, [1], false);
          if (i > 0) then
            cResult = Result[i];
          else
            i = LengthOfArray(Result) + 1;
            cResult = [vActionDate, 0, 0];
          fi;
          if (КорИмяКлассаЗаписей = 'Газета') then -- исключение отсылок
            if (cRec.ActionType = wsRecCreated) and (cRec.StoredValL = false) then
              vCreateCount = (cResult[3] as Integer) + 1;
              Result[i] = [vActionDate, 0, vCreateCount];
            fi;
          elsif (КорИмяКлассаЗаписей = 'НомерГазеты') then -- только "принятые номера"
            if (cRec.ActionType = wsAccepted) then
              vCreateCount = (cResult[3] as Integer) + 1;
              Result[i] = [vActionDate, 0, vCreateCount];
            fi;
          elsif (КорИмяКлассаЗаписей = 'ЕдиницаХранения') then -- только "подшитые" в учетный документ
            if (cRec.ActionType = wsAccepted) then
              vCreateCount = (cResult[3] as Integer) + cRec.StoredValI; -- суммируется количество номеров
              Result[i] = [vActionDate, 0, vCreateCount];
            fi;
          elsif (КорИмяКлассаЗаписей = 'УчетныйДокумент') then -- все
            if (cRec.ActionType = wsRecCreated) and (cRec.StoredValL = false) then
              vCreateCount = (cResult[3] as Integer) + 1;
              Result[i] = [vActionDate, 0, vCreateCount];
            fi;
          fi;
          Next;
        od;
      end;
      SortArray(Result, [1]);
    fi;
  end;

  proc ПроставитьНомераСмен(var aResult :Variant[2]; aWorkShift :Variant[2]);
    --var aWorkShift :Variant[2]; -- номера смен [[vDate, vNumber]]
    var i, j :Integer;
    var cResult :Variant[];
    var vActionDate  :Date;
    aWorkShift = ПолучитьНомераСмен;
    for i = 1 .. LengthOfArray(aResult) do
      cResult = aResult[i] as Variant[];
      vActionDate = cResult[1] as Date;
      j = SearchInArray(aWorkShift, vActionDate, [1], true);
      if (j > 0) then
        aResult[i,2] = aWorkShift[j,2] as Integer;
      fi;
    od;
  end;


end