class inherited РКП_СИС.блОтчетОРаботеБазовый "Уточняющий отчет по вводу данных";

import СИС2 classes Константы;
import РКП_СИС classes StdCode, Recs, Functions, FilterMaker, Def, StringsFunctions, RI.intBase;

inobject private

--{{ 2_Свойства

  var КомпетенцииВОтчете :tCompetence[];

  var фреймОтчет   :TemplateFrame;
  var секцГазеты   :TemplateSection;

  var Отдел        :String;
  var РазделОснОтч :String;
  var ТипДействия  :RI.intBase.tWorkState;
  var ОператорИмя  :String;

  var мДанные :Variant[2];
  var ВсегоГазет :Integer;
  var ВсегоНомеров :Integer;

  var стлбГазетаДатаСздЗгл :TemplateColumn;
  var стлбГазетаДатаСзд    :TemplateColumn;
  var стлбГазетаДатаИзмЗгл :TemplateColumn;
  var стлбГазетаДатаИзм    :TemplateColumn;
  var стлбНомераСздЗгл     :TemplateColumn;
  var стлбНомераСзд        :TemplateColumn;
  var стлбНомераИзмЗгл     :TemplateColumn;
  var стлбНомераИзм        :TemplateColumn;
  var стлбНомераИтог       :TemplateColumn;

--}}

-- 2_Конструкторы, визуализаторы0. --

inclass public

  proc ПоГазетам (локОтдел, локРазделОснОтч :String;
                  локОператорИмя, локОператорПолнИмя :String;
                  локДатаН, локДатаК:Date;
                  локТипДействия :RI.intBase.tWorkState);
    var vFrm :УчетГазет.Отчеты.блПротоколВвода_Детализация;
    vFrm = УчетГазет.Отчеты.блПротоколВвода_Детализация.Create;
    vFrm.Отдел        = локОтдел;
    vFrm.РазделОснОтч = локРазделОснОтч;
    vFrm.ОператорИмя  = локОператорИмя;
    vFrm.Библиограф   = локОператорПолнИмя;
    vFrm.ДатаН        = локДатаН;
    vFrm.ДатаК        = локДатаК;
    vFrm.ТипДействия  = локТипДействия;
    if (локОтдел = 'ОРГП') then
      vFrm.КомпетенцииВОтчете = [кмпОРГПзав, кмпОРГПсотр];
    fi;
    vFrm.ShowEx(,Kernel.Window.PopupWindow);
  end;


inobject private

-- 2_Обработчики событий шаблона0. --

  proc шаблон_ПриОткрытии(Create :Logical);
    var j :Integer;
    inherited шаблон_ПриОткрытии(Create);
    ПостроитьОтчет;
    j = УчетГазет.Отчеты.блПротоколВвода_Детализация.ObjectsCount;
    if (j > 1) then
      Self.Window.Left = УчетГазет.Отчеты.блПротоколВвода_Детализация.Objects[j - 1].Window.Left + 40;
      Self.Window.Top = УчетГазет.Отчеты.блПротоколВвода_Детализация.Objects[j - 1].Window.Top + 40;
    fi;
    стлбГазетаДатаСздЗгл.Visible = (РазделОснОтч = 'Газеты') and (ТипДействия = wsRecCreated);
    стлбГазетаДатаСзд.Visible    = (РазделОснОтч = 'Газеты') and (ТипДействия = wsRecCreated);
    стлбГазетаДатаИзмЗгл.Visible = (РазделОснОтч = 'Газеты') and (ТипДействия = wsRecUpdated);
    стлбГазетаДатаИзм.Visible    = (РазделОснОтч = 'Газеты') and (ТипДействия = wsRecUpdated);
    стлбНомераСздЗгл.Visible     = (РазделОснОтч = 'Номера') and (ТипДействия = wsRecCreated);
    стлбНомераСзд.Visible        = (РазделОснОтч = 'Номера') and (ТипДействия = wsRecCreated);
    стлбНомераИзмЗгл.Visible     = (РазделОснОтч = 'Номера') and (ТипДействия = wsRecUpdated);
    стлбНомераИзм.Visible        = (РазделОснОтч = 'Номера') and (ТипДействия = wsRecUpdated);
    стлбНомераИтог.Visible       = (РазделОснОтч = 'Номера');
    фреймОтчет.FreezeArea(0, 0, 0, 6.5);
  end;


-- 2_Обработчики событий клеток шаблона0. --

  func Поле_ПриВыводе_ЗаголовокОкнаФормы(Cell :TemplateCell; Value :Variant; Action :Template.OutputTypes; var Format :String) :Variant;
    var vTitleBeg, vTitleEnd :String;
    vTitleBeg = Библиограф  + Br;
    if true in [Hour(ДатаК) > 0, Minute(ДатаК) > 0, Second(ДатаК) > 0] then
      vTitleEnd = Br + '<s-><s->за период с ' + Str(ДатаН) + ' по  ' + Str(ДатаК, 'dd mmmm yyyy г. (hh:mm:ss)') + ' включительно';
    else
      vTitleEnd = Br + '<s-><s->за период с ' + Str(ДатаН) + ' по  ' + Str(ДатаК) + ' включительно';
    fi;
    if (Отдел = 'ОРГП') then
      if (РазделОснОтч = 'Газеты') and (ТипДействия = wsRecCreated) then    Result = vTitleBeg + 'зарегистрировано новых изданий, кроме отсылок'     + vTitleEnd;
      elsif (РазделОснОтч = 'Газеты') and (ТипДействия = wsRecUpdated) then Result = vTitleBeg + 'изменено ранее созданных записей, включая отсылки' + vTitleEnd;
      elsif (РазделОснОтч = 'Номера') and (ТипДействия = wsRecCreated) then Result = vTitleBeg + 'зарегистрировано номеров (выпусков)' + vTitleEnd;
      fi;
    fi;
  end;

  func Поле_ПриВыводе_мГазета(Cell :TemplateCell; Value :Variant; Action :Template.OutputTypes; var Format :String) :Variant;
    var vIndex :Integer;
    var cData :Variant[];
    vIndex = Cell.Frame;
    try
      if (РазделОснОтч in ['Газеты', 'Номера']) then
        cData = мДанные[vIndex] as Variant[];
        Result = cData[4] as String;
      fi;
    finally
    end;
  end;

  func Поле_ПриВыводе_мГазетаДата(Cell :TemplateCell; Value :Variant; Action :Template.OutputTypes; var Format :String) :Variant;
    var vIndex :Integer;
    var cData :Variant[];
    var vDate :Date;
    vIndex = Cell.Frame;
    try
      if (РазделОснОтч = 'Газеты') then
        cData = мДанные[vIndex] as Variant[];
        vDate = (cData[3] as Date);
        if (vDate <> nil) then
          Result = vDate;
        fi;
      fi;
    finally
    end;
  end;

  func Поле_ПриВыводе_мГазетаКоличество(Cell :TemplateCell; Value :Variant; Action :Template.OutputTypes; var Format :String) :Variant;
    var vIndex :Integer;
    var cData :Variant[];
    vIndex = Cell.Frame;
    try
      if (РазделОснОтч = 'Номера') then
        cData = мДанные[vIndex] as Variant[];
        Result = (cData[2] as Integer);
      fi;
    finally
    end;
  end;


-- 2_Обработчики событий прочих объектов шаблона0. --


-- 2_Дополнительные команды0. --


-- 2_Вспомогательные методы0. --

  proc ЗагрузитьФреймУправление;
    -- здесь ничего не должно выполняться
  end;

  proc УсловияОтбораНовогоОтчета;
    -- здесь ничего не должно выполняться
  end;

  func ПостроитьОтчет :Logical;
    --var aResult :Variant[2]; --[[vRecord, vCount]]
    Hint('Выполнение...');
    if (not nil in [ДатаН,ДатаК]) and (ДатаН<=ДатаК) then
      УдалитьРезультатыРасчета;
      мДанные = ПолучитьВыборку;
      секцГазеты.FramesCount = LengthOfArray(мДанные);
      Return true;
    else
      Message('Введен некорректный период! Перестроение отчета невозможно.');
    fi;
  end;

  proc УдалитьРезультатыРасчета;
    мДанные = nil;
    ВсегоГазет = 0;
    ВсегоНомеров = 0;
    секцГазеты.FramesCount = 0;
  end;

  func ПолучитьВыборку :Variant[2];  -- [[vRecord, vCount]]
    if (Отдел = 'ОРГП') then
      if (РазделОснОтч = 'Газеты') then
        Result = ПолучитьВыборку_Газет;
      elsif (РазделОснОтч = 'Номера') then
        Result = ПолучитьВыборку_Номеров;
      fi;
    fi;
  end;

  func ПолучитьВыборку_Газет :Variant[2]; -- [[vRecordNsp, vCount, vDate, vName]]
    var КорИмяКлассаЗаписей :String;
    var vFlt :String;
    var aRIDDeleted, aRIDCreated, aRIDUpdated :Integer[];
    var j, jj, i :Integer;
    var cRec :РКП_СИС.ЛогРабот;
    var cRID :Integer;
    КорИмяКлассаЗаписей = 'Газета';
    vFlt = ПолучитьФильтрЗапросаЛога(КорИмяКлассаЗаписей);
    aRIDDeleted = ПолучитьУдаленныеЗаписи(vFlt, КорИмяКлассаЗаписей);
    with Query.Create([РКП_СИС.ЛогРабот]) do
      Filter = vFlt;
      Order = 'DocId-';
      Select;
      jj = Count;
      while not Eof do
        j = j + 1;
        Hint('Извлечение данных... [' + КорИмяКлассаЗаписей + ']', j, jj);
        cRec = Current as РКП_СИС.ЛогРабот;
        cRID = cRec.RID;
        if (ТипДействия = wsRecCreated) then
          if (SearchInArray(aRIDDeleted, cRID, ,true) < 0) then
            if not (cRID in aRIDCreated) then
              i = i + 1;
              Result[i, 1] = GetRecordByRef('{РКП_Газеты.Газета:' + Str(cRID) + '}');
              Result[i, 2] = 1;
              Result[i, 3] = cRec.CreateDate;
              if (Result[i, 1] is РКП_Газеты.Газета) then
                Result[i, 4] = (Result[i, 1] as РКП_Газеты.Газета).НазваниеОсн;
              fi;
              AddInArray(aRIDCreated, cRID);
            fi;
          fi;
        elsif (ТипДействия = wsRecUpdated) then
          if (SearchInArray(aRIDDeleted, cRID, ,true) < 0) then
            if not (cRID in aRIDUpdated) then
              i = i + 1;
              Result[i, 1] = GetRecordByRef('{РКП_Газеты.Газета:' + Str(cRID) + '}');
              Result[i, 2] = 1;
              Result[i, 3] = cRec.UpdateDate;
              if (Result[i, 1] is РКП_Газеты.Газета) then
                Result[i, 4] = (Result[i, 1] as РКП_Газеты.Газета).НазваниеОсн;
              fi;
              AddInArray(aRIDUpdated, cRID);
            fi;
          fi;
        fi;
        Next;
      od;
    end;
    ВсегоГазет = i;
    SortArray(Result, [4]);
    Hint(' ');
  end;

  func ПолучитьВыборку_Номеров :Variant[2]; --  [[vRecordNsp, vCount, vDate, vName]]
    var КорИмяКлассаЗаписей :String;
    var aFlt :String[];
    var vFlt :String;
    var aRIDDeleted, aRIDCreated, aRIDUpdated, aRIDAccepted :Integer[];
    var j, jj, i :Integer;
    var cRecIssue :РКП_Газеты.НомерГазеты;
    var cRecNsp :РКП_Газеты.Газета;
    var cRec :РКП_СИС.ЛогРабот;
    var cResult :Variant[];
    var vCreateCount, vUpdateCount, cRID :Integer;
    var aRslt :Variant[2];
    КорИмяКлассаЗаписей = 'НомерГазеты';
    -- 1 Зарегистрированные - по алгоритму справки о пополнении БД
    if (ТипДействия = wsRecCreated) then
      AddInArray( aFlt, 'Газета<>nil' );
      AddInArray( aFlt, 'ФункцияГруппы=0' );
      AddInArray( aFlt, 'НеПолучен=false' );
      AddInArray( aFlt, 'ПринялНаХранение="' + ОператорИмя + '"' );
      AddInArray( aFlt, 'ДатаПринятияНаХранение>=' + Str(ДатаН) );
      AddInArray( aFlt, 'ДатаПринятияНаХранение<'  + Str(ДатаК) );
      with Query.Create([РКП_Газеты.НомерГазеты]) do
        OpenHint[Query.Interrupted] = true;
        Filter = MakeFilter( aFlt );
        Order = 'Газета';
        Select;
        jj = Count;
        while not Eof do
          j = j + 1;
          Hint('Извлечение данных... [' + КорИмяКлассаЗаписей + ']', j, jj);
          cRecIssue = Current as РКП_Газеты.НомерГазеты;
          cRecNsp = cRecIssue.Газета;
          i = SearchInArray(Result, cRecNsp, [1]);
          if (i < 0) then
            i = LengthOfArray(Result) + 1;
            Result[i,1] = cRecNsp;
            Result[i,4] = cRecNsp.НазваниеОсн;
          fi;
          cResult = Result[i] as Variant[];
          cRID = cRecIssue.DocID;
          vCreateCount = cResult[2] as Integer;
          aRIDCreated  = cResult[5] as Integer[];
          if not (cRID in aRIDCreated) then
            vCreateCount = vCreateCount + 1;
            AddInArray(aRIDCreated, cRID);
          fi;
          cResult[2] = vCreateCount;
          cResult[5] = aRIDCreated;
          Result[i] = cResult;
          Next;
        od;
      end;
    fi;
    -- 2 Измененные - по логу
    if (ТипДействия = wsRecUpdated) then
      -- 2.1 Получение [ID] удаленных записей
      vFlt = ПолучитьФильтрЗапросаЛога(КорИмяКлассаЗаписей);
      aRIDDeleted = ПолучитьУдаленныеЗаписи(vFlt, КорИмяКлассаЗаписей);
      -- 2.2 Получение результата
      aFlt = nil;
      AddInArray( aFlt, ПолучитьФильтрЗапросаЛога(КорИмяКлассаЗаписей) );
      AddInArray( aFlt, 'ActionType=' + Str(wsRecUpdated) );
      AddInArray( aFlt, 'not RID in ' + ToStr(aRIDDeleted) );
      vFlt = MakeFilter(aFlt);
      with Query.Create([РКП_СИС.ЛогРабот]) do
        OpenHint[Query.Interrupted] = true;
        Filter = vFlt;
        Select;
        jj = Count;
        j = 0;
        while not Eof do
          j = j + 1;
          Hint('Извлечение данных... [' + КорИмяКлассаЗаписей + ']', j, jj);
          cRec = Current as РКП_СИС.ЛогРабот;
          cRID = cRec.RID;
          cRecIssue = GetRecordByRef('{РКП_Газеты.НомерГазеты:' + Str(cRID) + '}');
          if (cRecIssue <> nil) then
            cRecNsp = cRecIssue.Газета;
            i = SearchInArray(Result, cRecNsp, [1]);
            if (i < 0) then
              i = LengthOfArray(Result) + 1;
              Result[i,1] = cRecNsp;
              Result[i,4] = cRecNsp.НазваниеОсн;
            fi;
            cResult = Result[i] as Variant[];
            vUpdateCount = cResult[2] as Integer;
            aRIDUpdated  = cResult[5] as Integer[];
            if  not (cRID in aRIDUpdated) then
              vUpdateCount = vUpdateCount + 1;
              AddInArray(aRIDUpdated, cRID);
              cResult[2] = vUpdateCount;
              cResult[5] = aRIDUpdated;
              Result[i] = cResult;
            fi;
          fi;
          Next;
        od;
      end;
    fi;
    for i = 1 .. LengthOfArray(Result) do
      cResult = Result[i] as Variant[];
      ВсегоНомеров = ВсегоНомеров + (cResult[2] as Integer);
    od;
    ВсегоГазет = LengthOfArray(Result);
    Hint(' ');
  end;

  func ПолучитьУдаленныеЗаписи( ОснФильтр, КорИмяКлассаЗаписей :String ) :Integer[];
    var aRslt: variant[2]; -- вспомогательная переменная для хранения результатов, возвращаемых агрегирующими функциями
    var aIdFromLog, aIdFromSource :Integer[];
    var rClass :Class Record;
    var i, ii :Integer;
    var Q :Query;
    -- Получение массива DocId записей, оставивших следы в логе
    with Query.Create([РКП_СИС.ЛогРабот]) do
      Order = 'RID';
      Filter = ОснФильтр;
      LoadingFieldsMode = mdNone;
      LoadingFields = 'RID';
      aRslt = CalcAggregates('GroupBy(RID)') as variant[2];
      aIdFromLog = aRslt[1] as Integer[];
      SortArray(aIdFromLog);
    end;
    if (aIdFromLog <> nil) then
      -- Определение класса записей с исходными данными
      if (КорИмяКлассаЗаписей = 'Газета')             then rClass = FindClass( 'РКП_Газеты.Газета' );
      elsif (КорИмяКлассаЗаписей = 'НомерГазеты')     then rClass = FindClass( 'РКП_Газеты.НомерГазеты' );
      elsif (КорИмяКлассаЗаписей = 'ЕдиницаХранения') then rClass = FindClass( 'РКП_Газеты.ЕдиницаХранения' );
      elsif (КорИмяКлассаЗаписей = 'УчетныйДокумент') then rClass = FindClass( 'РКП_Газеты.УчетныйДокумент' );
      fi;
      -- Получение массива DocId записей, не найденных в источнике (удаленных)
      with Query.Create([rClass]) do
        Order = 'DocId';
        Filter = 'DocId in ' + ToStr(aIdFromLog);
        LoadingFieldsMode = mdNone;
        LoadingFields = 'DocId';
        aRslt = CalcAggregates('GroupBy(DocId)') as variant[2];
        aIdFromSource = aRslt[1] as Integer[];
        SortArray(aIdFromSource);
      end;
      -- Получение массива удаленных записей
      ii = LengthOfArray(aIdFromLog);
      for i = 1 .. ii do
        Hint('Исключение из отчета удаленных данных... [' + КорИмяКлассаЗаписей + ']', i, ii);
        if not aIdFromLog[i] in aIdFromSource then
          AddInArray(Result, aIdFromLog[i]);
        fi;
      od;
      Hint(' ');
      SortArray(Result);
    fi;
  end;

  func ПолучитьФильтрЗапросаЛога( КорИмяКлассаЗаписей :String ) :String;
    var aFlt :String[];
    AddInArray( aFlt, ПолучитьФильтрКомпетенций );
    AddInArray( aFlt, ПолучитьФильтрДат );
    AddInArray( aFlt, ПолучитьФильтрКлассаЗаписей(КорИмяКлассаЗаписей) );
    AddInArray( aFlt, ПолучитьФильтрДействия );
    AddInArray( aFlt, ПолучитьФильтрОператора );
    AddInArray( aFlt, ПолучитьДопУсловие );
    Result = MakeFilter( aFlt );
  end;

  func ПолучитьФильтрКомпетенций :String;
    var i :Integer;
    var aFlt :String[];
    for i = 1 .. LengthOfArray(КомпетенцииВОтчете) do
      AddInArray( aFlt, 'Match(Competencies, "*|' + Str(КомпетенцииВОтчете[i]) + '|*")' );
    od;
    Result = MakeFilter( aFlt, byOr );
  end;

  func ПолучитьФильтрДат :String;
    var aFlt :String[];
    AddInArray( aFlt, 'CreateDate>=' + Str(ДатаН) );
    AddInArray( aFlt, 'CreateDate<'  + Str(ДатаК) );
    Result = MakeFilter( aFlt );
  end;

  func ПолучитьФильтрКлассаЗаписей( КорИмяКлассаЗаписей :String ) :String;
    if (КорИмяКлассаЗаписей = 'Газета')             then Result = 'RClass="РКП_Газеты.Газета"';
    elsif (КорИмяКлассаЗаписей = 'НомерГазеты')     then Result = 'RClass="РКП_Газеты.НомерГазеты"';
    elsif (КорИмяКлассаЗаписей = 'ЕдиницаХранения') then Result = 'RClass="РКП_Газеты.ЕдиницаХранения"';
    elsif (КорИмяКлассаЗаписей = 'УчетныйДокумент') then Result = 'RClass="РКП_Газеты.УчетныйДокумент"';
    fi;
  end;

  func ПолучитьФильтрДействия :String;
    if not ((Отдел = 'ОРГП') and (РазделОснОтч = 'Номера') and (ТипДействия = wsRecUpdated)) then
      Result = 'ActionType=' + Str(ТипДействия);
    fi;
  end;

  func ПолучитьФильтрОператора :String;
    Result = 'CreateUser="' + ОператорИмя + '"';
  end;

  func ПолучитьДопУсловие :String;
    if (Отдел = 'ОРГП') and (РазделОснОтч = 'Газеты') and (ТипДействия = wsRecCreated) then
      Result = 'not StoredValL';
    fi;
  end;


end