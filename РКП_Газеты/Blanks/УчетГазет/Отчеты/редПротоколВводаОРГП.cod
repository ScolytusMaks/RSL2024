class inherited РКП_СИС.редОтчетОРаботеБазовый "Сводный отчет по вводу данных", editor ПротоколВводаОРГП;

import СИС2 classes Константы;
import РКП_СИС classes StdCode, Recs, Functions, FilterMaker, Def, StringsFunctions, RI.intBase;

inobject private

--{{ 2_Свойства

  var Интерфейс :РКП_Газеты.RI.ПротоколВводаОРГП;

  var КомпетенцииВОтчете :tCompetence[] := [кмпОРГПзав, кмпОРГПсотр];

  var секцНомера      :TemplateSection;
  var секцГазеты      :TemplateSection;


--}}

-- 2_Конструкторы, визуализаторы0. --

inclass public

inobject private

-- 2_Обработчики событий шаблона0. --


-- 2_Обработчики событий клеток шаблона0. --

  func Поле_ПриВыводе_ЗаголовокОкнаФормы(Cell :TemplateCell; Value :Variant; Action :Template.OutputTypes; var Format :String) :Variant;
    Result = 'Протокол ввода данных ОРГП' + Br +
             '№ ' + Str(НомерОтчета) + ' / ' + Str(ЗаГод) + Br +
             '<s-><s->за период с ' + Str(ДатаН) + ' по  ' + Str(ДатаК) + ' включительно';
  end;

  func Поле_ПриНажатии_Уточнение(Cell :TemplateCell; Action :Template.ClickTypes) :Logical;
    var локФактДатаК :Date;
    if Dat(Day(UpdateDate), Mon(UpdateDate), Day(UpdateDate)) = Dat(Day(ДатаК), Mon(ДатаК), Day(ДатаК)) then
      локФактДатаК = AddSec(UpdateDate, 10);
    else
      локФактДатаК = ДатаК + 1;
    fi;
    if (Cell.Owner = секцГазеты) then
      if (Cell.Contents = 'Введено') then
        УчетГазет.Отчеты.блПротоколВвода_Детализация.ПоГазетам('ОРГП', 'Газеты', Газеты[Cell.Frame].ОператорИмя, Газеты[Cell.Frame].Оператор, ДатаН, локФактДатаК, RI.intBase.wsRecCreated );
      elsif (Cell.Contents = 'Редактировано') then
        УчетГазет.Отчеты.блПротоколВвода_Детализация.ПоГазетам('ОРГП', 'Газеты', Газеты[Cell.Frame].ОператорИмя, Газеты[Cell.Frame].Оператор, ДатаН, локФактДатаК, RI.intBase.wsRecUpdated );
      fi;
    fi;
  end;

  proc Поле_ПриВыходе_Комментарий(Cell :TemplateCell; Index :Integer);
    var locUpdateDate : Date;
    locUpdateDate = Record.UpdateDate;
    РКП_СИС.Recs.RecordPostIfNeed(Record);
    Record.UpdateDate = locUpdateDate;
  end;


-- 2_Обработчики событий прочих объектов шаблона0. --


-- 2_Дополнительные команды0. --


-- 2_Вспомогательные методы0. --

  proc НовыйНомер;
    if (Self.Record.State = Kernel.Record.Created) then
      ЗаГод = Year(today);
      with Query.Create([РКП_Газеты.ПротоколВводаОРГП]) do
        Filter = 'ЗаГод=' + Str(Year(today)) +' and DocID<>' + Str(Record.DocID);
        Order  = 'НомерОтчета-';
        Select;
        if not (RecordsExists) then
          НомерОтчета = 1;
        else
          НомерОтчета = (Current.НомерОтчета + 1);
        fi;
      end;
    fi;
  end;

  func ПостроитьОтчет :Logical;
    var aUserName :String[];
    var aUserFullName :String[2];
    var aResult :Variant[2]; --[[UserName, FullName, vCreateCount, vUpdateCount]]
    var i :Integer;
    var locUpdateDate : Date;
    if DebugMode then
      locUpdateDate = Record.UpdateDate;
    fi;
    Result = inherited ПостроитьОтчет; -- проверка корректности условий
    if Result then
      УдалитьРезультатыРасчета;
      РКП_СИС.Recs.RecordPostIfNeed(Record);
      aUserFullName = ПолучитьПолныеИменаПользователей;
      aUserName = ПолучитьИменаПользователей('Газета');
      if (aUserName <> nil) then
        aResult = ПолучитьВыборку(aUserName, 'Газета');
        РасшифроватьИмена(aResult, aUserFullName);
        for i = 1 .. LengthOfArray(aResult) do
          with Self.Record.Газеты.AddEx do
            ОператорИмя   = aResult[i,1] as String;
            Оператор      = aResult[i,2] as String;
            Введено       = aResult[i,3] as Integer;
            Редактировано = aResult[i,4] as Integer;
            ВсегоВведеноГазет       = ВсегоВведеноГазет       + aResult[i,3] as Integer;
            ВсегоРедактированоГазет = ВсегоРедактированоГазет + aResult[i,4] as Integer;
          end;
        od;
      fi;
      --
      aUserName = ПолучитьИменаПользователей('НомерГазеты');
      if (aUserName <> nil) then
        aResult = ПолучитьВыборку(aUserName, 'НомерГазеты');
        РасшифроватьИмена(aResult, aUserFullName);
        for i = 1 .. LengthOfArray(aResult) do
          with Self.Record.Номера.AddEx do
            ОператорИмя   = aResult[i,1] as String;
            Оператор      = aResult[i,2] as String;
            Введено       = aResult[i,3] as Integer;
            Редактировано = aResult[i,4] as Integer;
            ВсегоВведеноНомеров       = ВсегоВведеноНомеров       + aResult[i,3] as Integer;
            ВсегоРедактированоНомеров = ВсегоРедактированоНомеров + aResult[i,4] as Integer;
          end;
        od;
      fi;
      --
      aUserName = ПолучитьИменаПользователей('ЕдиницаХранения');
      if (aUserName <> nil) then
        aResult = ПолучитьВыборку(aUserName, 'ЕдиницаХранения');
        РасшифроватьИмена(aResult, aUserFullName);
        for i = 1 .. LengthOfArray(aResult) do
          with Self.Record.Поступления.AddEx do
            ОператорИмя   = aResult[i,1] as String;
            Оператор      = aResult[i,2] as String;
            Введено       = aResult[i,3] as Integer;
            Редактировано = aResult[i,4] as Integer;
            ВсегоВведеноПоступлений       = ВсегоВведеноПоступлений       + aResult[i,3] as Integer;
            ВсегоРедактированоПоступлений = ВсегоРедактированоПоступлений + aResult[i,4] as Integer;
          end;
        od;
      fi;
      --
      aUserName = ПолучитьИменаПользователей('УчетныйДокумент');
      if (aUserName <> nil) then
        aResult = ПолучитьВыборку(aUserName, 'УчетныйДокумент');
        РасшифроватьИмена(aResult, aUserFullName);
        for i = 1 .. LengthOfArray(aResult) do
          with Self.Record.УчДок.AddEx do
            ОператорИмя   = aResult[i,1] as String;
            Оператор      = aResult[i,2] as String;
            Введено       = aResult[i,3] as Integer;
            Редактировано = aResult[i,4] as Integer;
            ВсегоВведеноУчДок       = ВсегоВведеноУчДок       + aResult[i,3] as Integer;
            ВсегоРедактированоУчДок = ВсегоРедактированоУчДок + aResult[i,4] as Integer;
          end;
        od;
      fi;
      РКП_СИС.Recs.RecordPostIfNeed(Record);
      if DebugMode then
        Record.UpdateDate = locUpdateDate;
      fi;
    fi;
  end;

  proc УдалитьРезультатыРасчета;
    Газеты.Clear;
    Номера.Clear;
    Поступления.Clear;
    УчДок.Clear;
    ВсегоВведеноГазет         = nil;
    ВсегоРедактированоГазет   = nil;
    ВсегоВведеноНомеров       = nil;
    ВсегоРедактированоНомеров = nil;
    ВсегоВведеноПоступлений       = nil;
    ВсегоРедактированоПоступлений = nil;
    ВсегоВведеноУчДок             = nil;
    ВсегоРедактированоУчДок       = nil;
  end;

  func ПолучитьИменаПользователей( КорИмяКлассаЗаписей :String ) :String[];
    var QResult :Variant[2];
    with Query.Create([РКП_СИС.ЛогРабот]) do
      Filter = ПолучитьФильтрЗапросаЛога(КорИмяКлассаЗаписей);
      QResult = CalcAggregates('GroupBy(CreateUser)') as Variant[2];
    end;
    if (QResult <> nil) then
      Result = QResult[1] as String[];
      SortArray(Result);
    fi;
  end;

  func ПолучитьПолныеИменаПользователей :String[2];
    var cResult :String[];
    with Query.Create([Kernel.Settings.User]) do
      Filter = 'isGroup=0';
      Select;
      while not Eof do
        cResult = [Current.Name, Current.FullName] as String[];
        AddInArray( Result, cResult);
        Next;
      od;
    end;
    SortArray(Result, [1]);
  end;

  func ПолучитьФильтрЗапросаЛога( КорИмяКлассаЗаписей :String ) :String;
    var aFlt :String[];
    AddInArray( aFlt, ПолучитьФильтрКомпетенций );
    AddInArray( aFlt, ПолучитьФильтрДат );
    AddInArray( aFlt, ПолучитьФильтрКлассаЗаписей(КорИмяКлассаЗаписей) );
    Result = MakeFilter( aFlt );
  end;

  func ПолучитьФильтрКомпетенций :String;
    var i :Integer;
    var aFlt :String[];
    for i = 1 .. LengthOfArray(КомпетенцииВОтчете) do
      AddInArray( aFlt, 'Match(Competencies, "*|' + Str(КомпетенцииВОтчете[i]) + '|*")' );
    od;
    Result = MakeFilter( aFlt, byOr );
  end;

  func ПолучитьФильтрДат :String;
    var aFlt :String[];
    var локФактДатаК :Date;
    AddInArray( aFlt, 'CreateDate>=' + Str(ДатаН) );
    if Dat(Day(UpdateDate), Mon(UpdateDate), Day(UpdateDate)) = Dat(Day(ДатаК), Mon(ДатаК), Day(ДатаК)) then
      локФактДатаК = AddSec(UpdateDate, 10);
    else
      локФактДатаК = ДатаК + 1;
    fi;
    AddInArray( aFlt, 'CreateDate<' + Str(локФактДатаК) );
    Result = MakeFilter( aFlt );
  end;

  func ПолучитьФильтрКлассаЗаписей( КорИмяКлассаЗаписей :String ) :String;
    if (КорИмяКлассаЗаписей = 'Газета')             then Result = 'RClass="РКП_Газеты.Газета"';
    elsif (КорИмяКлассаЗаписей = 'НомерГазеты')     then Result = 'RClass="РКП_Газеты.НомерГазеты"';
    elsif (КорИмяКлассаЗаписей = 'ЕдиницаХранения') then Result = 'RClass="РКП_Газеты.ЕдиницаХранения"';
    elsif (КорИмяКлассаЗаписей = 'УчетныйДокумент') then Result = 'RClass="РКП_Газеты.УчетныйДокумент"';
    fi;
  end;

  func ПолучитьВыборку(aUserName :String[]; КорИмяКлассаЗаписей :String ) :Variant[2];  --[[UserName, nil, vCreateCount, vUpdateCount]]
    if (aUserName <> nil) then
      if (КорИмяКлассаЗаписей = 'Газета')             then Result = ПолучитьВыборку_Газет   (aUserName, КорИмяКлассаЗаписей);
      elsif (КорИмяКлассаЗаписей = 'НомерГазеты')     then Result = ПолучитьВыборку_Номеров (aUserName, КорИмяКлассаЗаписей);
      elsif (КорИмяКлассаЗаписей = 'ЕдиницаХранения') then Result = ПолучитьВыборку_ЕХ (aUserName, КорИмяКлассаЗаписей);
      elsif (КорИмяКлассаЗаписей = 'УчетныйДокумент') then Result = ПолучитьВыборку_УД (aUserName, КорИмяКлассаЗаписей);
      fi;
    fi;
  end;

  func ПолучитьВыборку_Газет(aUserName :String[]; КорИмяКлассаЗаписей :String ) :Variant[2];  --[[UserName, nil, vCreateCount, vUpdateCount]]
    var vFlt :String;
    var aRIDDeleted, aRIDCreated, aRIDUpdated :Integer[];
    var j, jj, i :Integer;
    var cRec :РКП_СИС.ЛогРабот;
    var cResult :Variant[];
    var vCreateCount, vUpdateCount, cRID :Integer;
    vFlt = ПолучитьФильтрЗапросаЛога(КорИмяКлассаЗаписей);
    aRIDDeleted = ПолучитьУдаленныеЗаписи(vFlt, КорИмяКлассаЗаписей);
    with Query.Create([РКП_СИС.ЛогРабот]) do
      OpenHint[Query.Interrupted] = true;
      Filter = vFlt;
      Order = 'RID';
      Select;
      jj = Count;
      while not Eof do
        j = j + 1;
        Hint('Извлечение данных... [' + КорИмяКлассаЗаписей + ']', j, jj);
        cRec = Current as РКП_СИС.ЛогРабот;
        if (SearchInArray(aRIDDeleted, cRec.RID, ,true) < 0) then
          i = SearchInArray(aUserName, cRec.CreateUser, , true);
          if (i > 0) then
            cResult = Result[i] as Variant[];
            vCreateCount = cResult[3] as Integer;
            vUpdateCount = cResult[4] as Integer;
            cRID = cRec.RID;
            aRIDUpdated = cResult[5] as Integer[];
            if not (cRID in aRIDCreated) then
              if (cRec.ActionType = wsRecCreated) and (cRec.StoredValL = false) then
                vCreateCount = vCreateCount + 1;
                AddInArray(aRIDCreated, cRID);
              fi;
            fi;
            aRIDUpdated = cResult[6] as Integer[];
            if not (cRID in aRIDUpdated) then       --not (cRID in aRIDCreated) and
              if (cRec.ActionType = wsRecUpdated) then
                vUpdateCount = vUpdateCount + 1;
                AddInArray(aRIDUpdated, cRID);
                cResult[5] = aRIDUpdated;
              fi;
            fi;
            cResult = [aUserName[i] ,nil, vCreateCount, vUpdateCount, aRIDUpdated, aRIDUpdated];
            Result[i] = cResult;
          fi;
        fi;
        Next;
      od;
    end;
    Hint(' ');
  end;

  func ПолучитьВыборку_Номеров(aUserName :String[]; КорИмяКлассаЗаписей :String ) :Variant[2];  --[[UserName, nil, vCreateCount, vUpdateCount]]
    var aFlt :String[];
    var vFlt :String;
    var aRIDDeleted, aRIDCreated, aRIDUpdated :Integer[];
    var j, jj, i :Integer;
    var cRec :РКП_СИС.ЛогРабот;
    var cResult :Variant[];
    var vCreateCount, vUpdateCount, cRID :Integer;
    var локФактДатаК :Date;
    -- 1 Зарегистрированные - по алгоритму справки о пополнении БД
    AddInArray( aFlt, 'Газета<>nil' );
    AddInArray( aFlt, 'ФункцияГруппы=0' );
    AddInArray( aFlt, 'НеПолучен=false' );
    AddInArray( aFlt, 'ПринялНаХранение<>"Администратор"' );
    AddInArray( aFlt, 'ДатаПринятияНаХранение>=' + Str(ДатаН) );
    if Dat(Day(UpdateDate), Mon(UpdateDate), Day(UpdateDate)) = Dat(Day(ДатаК), Mon(ДатаК), Day(ДатаК)) then
      локФактДатаК = AddSec(UpdateDate, 10);
    else
      локФактДатаК = ДатаК + 1;
    fi;
    AddInArray( aFlt, 'ДатаПринятияНаХранение<'  + Str(локФактДатаК) );
    with Query.Create([РКП_Газеты.НомерГазеты]) do
      OpenHint[Query.Interrupted] = true;
      Filter = MakeFilter( aFlt );
      Order = 'ПринялНаХранение';
      LoadingFieldsMode = СИС2.Константы.mdNone;
      LoadingFields = 'DocId;ПринялНаХранение';
      Select;
      jj = Count;
      while not Eof do
        j = j + 1;
        Hint('Извлечение данных (1)... [' + КорИмяКлассаЗаписей + ']', j, jj);
        i = SearchInArray(aUserName, Current.ПринялНаХранение, , true);
        if (i > 0) then
          cResult = Result[i] as Variant[];
          vCreateCount = cResult[3] as Integer;
          cRID = Current.DocID;
          if not (cRID in aRIDCreated) then
            vCreateCount = vCreateCount + 1;
            AddInArray(aRIDCreated, cRID);
          fi;
          cResult = [aUserName[i],nil,vCreateCount, vUpdateCount];
          Result[i] = cResult;
        fi;
        Next;
      od;
    end;
    -- 2 Измененные - по логу
    vFlt = ПолучитьФильтрЗапросаЛога(КорИмяКлассаЗаписей);
    aRIDDeleted = ПолучитьУдаленныеЗаписи(vFlt, КорИмяКлассаЗаписей);
    with Query.Create([РКП_СИС.ЛогРабот]) do
      OpenHint[Query.Interrupted] = true;
      Filter = vFlt;
      Order = 'DocId-';
      Select;
      jj = Count;
      j = 0;
      while not Eof do
        j = j + 1;
        Hint('Извлечение данных (2)... [' + КорИмяКлассаЗаписей + ']', j, jj);
        cRec = Current as РКП_СИС.ЛогРабот;
        if (SearchInArray(aRIDDeleted, cRec.RID, ,true) < 0) then
          i = SearchInArray(aUserName, cRec.CreateUser, , true);
          if (i > 0) then
            cResult = Result[i] as Variant[];
            vCreateCount = cResult[3] as Integer;
            vUpdateCount = cResult[4] as Integer;
            cRID = cRec.RID;
            if not (cRID in aRIDCreated) and not (cRID in aRIDUpdated) then
              if (cRec.ActionType = wsRecUpdated) then
                vUpdateCount = vUpdateCount + 1;
                AddInArray(aRIDUpdated, cRID);
              fi;
            fi;
            cResult = [aUserName[i],nil,vCreateCount, vUpdateCount];
            Result[i] = cResult;
          fi;
        fi;
        Next;
      od;
    end;
    Hint(' ');
  end;

  func ПолучитьВыборку_ЕХ(aUserName :String[]; КорИмяКлассаЗаписей :String ) :Variant[2];  --[[UserName, nil, vCreateCount, vUpdateCount]]
    var vFlt :String;
    var aRIDDeleted, aRIDAccepted :Integer[];
    var j, jj, i :Integer;
    var cRec :РКП_СИС.ЛогРабот;
    var cResult :Variant[];
    var vCreateCount, vUpdateCount, cRID :Integer;
    vFlt = ПолучитьФильтрЗапросаЛога(КорИмяКлассаЗаписей);
    aRIDDeleted = ПолучитьУдаленныеЗаписи(vFlt, КорИмяКлассаЗаписей);
    with Query.Create([РКП_СИС.ЛогРабот]) do
      OpenHint[Query.Interrupted] = true;
      Filter = vFlt;
      Order = 'DocId-';
      Select;
      jj = Count;
      while not Eof do
        j = j + 1;
        Hint('Извлечение данных... [' + КорИмяКлассаЗаписей + ']', j, jj);
        cRec = Current as РКП_СИС.ЛогРабот;
        if (SearchInArray(aRIDDeleted, cRec.RID, ,true) < 0) then
          i = SearchInArray(aUserName, cRec.CreateUser, , true);
          if (i > 0) then
            cResult = Result[i] as Variant[];
            vCreateCount = cResult[3] as Integer;
            cRID = cRec.RID;
            if not (cRID in aRIDAccepted) then
              if (cRec.ActionType = wsAccepted) then
                vCreateCount = vCreateCount + cRec.StoredValI; -- суммируется количество номеров
                AddInArray(aRIDAccepted, cRID);
              fi;
            fi;
            cResult = [aUserName[i],nil,vCreateCount, vUpdateCount];
            Result[i] = cResult;
          fi;
        fi;
        Next;
      od;
    end;
    Hint(' ');
  end;

  func ПолучитьВыборку_УД(aUserName :String[]; КорИмяКлассаЗаписей :String ) :Variant[2];  --[[UserName, nil, vCreateCount, vUpdateCount]]
    var vFlt :String;
    var aRIDDeleted, aRIDCreated, aRIDUpdated :Integer[];
    var j, jj, i :Integer;
    var cRec :РКП_СИС.ЛогРабот;
    var cResult :Variant[];
    var vCreateCount, vUpdateCount, cRID :Integer;
    vFlt = ПолучитьФильтрЗапросаЛога(КорИмяКлассаЗаписей);
    aRIDDeleted = ПолучитьУдаленныеЗаписи(vFlt, КорИмяКлассаЗаписей);
    with Query.Create([РКП_СИС.ЛогРабот]) do
      OpenHint[Query.Interrupted] = true;
      Filter = vFlt;
      Order = 'DocId-';
      Select;
      jj = Count;
      while not Eof do
        j = j + 1;
        Hint('Извлечение данных... [' + КорИмяКлассаЗаписей + ']', j, jj);
        cRec = Current as РКП_СИС.ЛогРабот;
        if (SearchInArray(aRIDDeleted, cRec.RID, ,true) < 0) then
          i = SearchInArray(aUserName, cRec.CreateUser, , true);
          if (i > 0) then
            cResult = Result[i] as Variant[];
            vCreateCount = cResult[3] as Integer;
            vUpdateCount = cResult[4] as Integer;
            cRID = cRec.RID;
            if not (cRID in aRIDCreated) then
              if (cRec.ActionType = wsRecCreated) then
                vCreateCount = vCreateCount + 1;
                AddInArray(aRIDCreated, cRID);
              fi;
            fi;
            if not (cRID in aRIDCreated) and not (cRID in aRIDUpdated) then
              if (cRec.ActionType = wsRecUpdated) then
                vUpdateCount = vUpdateCount + 1;
                AddInArray(aRIDUpdated, cRID);
              fi;
            fi;
            cResult = [aUserName[i],nil,vCreateCount, vUpdateCount];
            Result[i] = cResult;
          fi;
        fi;
        Next;
      od;
    end;
    Hint(' ');
  end;

  proc РасшифроватьИмена(var aResult :Variant[2]; aUserFullName :String[2]);
    var vUserFullName :String;
    var i, j :Integer;
    for i = 1 .. LengthOfArray(aResult) do
      j = SearchInArray(aUserFullName, aResult[i,1] as String, [1], true);
      if (j > 0) then
        vUserFullName = aUserFullName[j,2];
      fi;
      if (vUserFullName <> nil) then
        aResult[i]  = [aResult[i,1], vUserFullName, aResult[i,3], aResult[i,4]];
      else
        aResult[i]  = [aResult[i,1], aResult[i,1], aResult[i,3], aResult[i,4]];
      fi;
    od;
  end;

  func ПолучитьУдаленныеЗаписи( ОснФильтр, КорИмяКлассаЗаписей :String ) :Integer[];
    var aRslt: variant[2]; -- вспомогательная переменная для хранения результатов, возвращаемых агрегирующими функциями
    var aIdFromLog :Integer[];
    var rClass :Class Record;
    var i, ii :Integer;
    var Q :Query;
    -- Получение массива DocId записей, оставивших следы в логе
    with Query.Create([РКП_СИС.ЛогРабот]) do
      Order = 'RID';
      Filter = ОснФильтр;
      LoadingFieldsMode = mdNone;
      LoadingFields = 'RID';
      aRslt = CalcAggregates('GroupBy(RID)') as variant[2];
      aIdFromLog = aRslt[1] as Integer[];
      SortArray(aIdFromLog);
    end;
    if (aIdFromLog <> nil) then
      -- Определение класса записей с исходными данными
      if (КорИмяКлассаЗаписей = 'Газета')             then rClass = FindClass( 'РКП_Газеты.Газета' );
      elsif (КорИмяКлассаЗаписей = 'НомерГазеты')     then rClass = FindClass( 'РКП_Газеты.НомерГазеты' );
      elsif (КорИмяКлассаЗаписей = 'ЕдиницаХранения') then rClass = FindClass( 'РКП_Газеты.ЕдиницаХранения' );
      elsif (КорИмяКлассаЗаписей = 'УчетныйДокумент') then rClass = FindClass( 'РКП_Газеты.УчетныйДокумент' );
      fi;
      Q = Query.Create([rClass]);
      Q.LoadingFieldsMode = mdNone;
      Q.LoadingFields = 'DocId';
      Q.Order = 'DocId';
      Q.Select;
      -- Получение массива DocId записей, не найденных в источнике (удаленных)
      ii = LengthOfArray(aIdFromLog);
      for i = 1 .. ii do
        Hint('Исключение из отчета удаленных данных... [' + КорИмяКлассаЗаписей + ']', i, ii);
        if not Q.Find(aIdFromLog[i]) then
          AddInArray(Result, aIdFromLog[i]);
        fi;
      od;
      Hint(' ');
      SortArray(Result);
    fi;
  end;


end