class inherited РКП_СИС.редОтчетОРаботеБазовый "Сводный отчет по вводу данных", editor ПротоколВводаОРГП;

import РКП_СИС classes StdCode, Recs, Functions, FilterMaker, Def, StringsFunctions, RI.intBase;

inobject private

--{{ 2_Свойства

  var Интерфейс :РКП_Газеты.RI.ПротоколВводаОРГП;

  var КомпетенцииВОтчете :tCompetence[] := [кмпОРГПзав, кмпОРГПсотр];

  var секцНомера      :TemplateSection;
  var секцГазеты      :TemplateSection;

--}}

-- 2_Конструкторы, визуализаторы0. --

inclass public

inobject private

-- 2_Обработчики событий шаблона0. --


-- 2_Обработчики событий клеток шаблона0. --

  func Поле_ПриВыводе_ЗаголовокОкнаФормы(Cell :TemplateCell; Value :Variant; Action :Template.OutputTypes; var Format :String) :Variant;
    Result = 'Протокол ввода данных ОРГП' + Br +
             '№ ' + Str(НомерОтчета) + ' / ' + Str(ЗаГод) + Br +
             '<s-><s->за период с ' + Str(ДатаН) + ' по  ' + Str(ДатаК) + ' включительно';
  end;


-- 2_Обработчики событий прочих объектов шаблона0. --


-- 2_Дополнительные команды0. --


-- 2_Вспомогательные методы0. --

  proc НовыйНомер;
    if (Self.Record.State = Kernel.Record.Created) then
      ЗаГод = Year(today);
      with Query.Create([РКП_Газеты.ПротоколВводаОРГП]) do
        Filter = 'ЗаГод=' + Str(Year(today)) +' and DocID<>' + Str(Record.DocID);
        Order  = 'НомерОтчета-';
        Select;
        if not (RecordsExists) then
          НомерОтчета = 1;
        else
          НомерОтчета = (Current.НомерОтчета + 1);
        fi;
      end;
    fi;
  end;

  func ПостроитьОтчет :Logical;
    var aUserName :String[];
    var aUserFullName :String[2];
    var aResult :Variant[2]; --[[UserName, FullName, vCreateCount, vUpdateCount]]
    var i :Integer;
    Result = inherited ПостроитьОтчет;
    if Result then
      Газеты.Clear;
      Номера.Clear;
      Поступления.Clear;
      УчДок.Clear;
      ВсегоВведеноГазет         = nil;
      ВсегоРедактированоГазет   = nil;
      ВсегоВведеноНомеров       = nil;
      ВсегоРедактированоНомеров = nil;
      ВсегоВведеноПоступлений       = nil;
      ВсегоРедактированоПоступлений = nil;
      ВсегоВведеноУчДок             = nil;
      ВсегоРедактированоУчДок       = nil;
      aUserFullName = ПолучитьПолныеИменаПользователей;
      aUserName = ПолучитьИменаПользователей('Газета');
      if (aUserName <> nil) then
        aResult = ПолучитьВыборку(aUserName, 'Газета');
        РасшифроватьИмена(aResult, aUserFullName);
        for i = 1 .. LengthOfArray(aResult) do
          with Self.Record.Газеты.AddEx do
            ОператорИмя   = aResult[i,1] as String;
            Оператор      = aResult[i,2] as String;
            Введено       = aResult[i,3] as Integer;
            Редактировано = aResult[i,4] as Integer;
            ВсегоВведеноГазет       = ВсегоВведеноГазет       + aResult[i,3] as Integer;
            ВсегоРедактированоГазет = ВсегоРедактированоГазет + aResult[i,4] as Integer;
          end;
        od;
      fi;
      --
      aUserName = ПолучитьИменаПользователей('НомерГазеты');
      if (aUserName <> nil) then
        aResult = ПолучитьВыборку(aUserName, 'НомерГазеты');
        РасшифроватьИмена(aResult, aUserFullName);
        for i = 1 .. LengthOfArray(aResult) do
          with Self.Record.Номера.AddEx do
            ОператорИмя   = aResult[i,1] as String;
            Оператор      = aResult[i,2] as String;
            Введено       = aResult[i,3] as Integer;
            Редактировано = aResult[i,4] as Integer;
            ВсегоВведеноНомеров       = ВсегоВведеноНомеров       + aResult[i,3] as Integer;
            ВсегоРедактированоНомеров = ВсегоРедактированоНомеров + aResult[i,4] as Integer;
          end;
        od;
      fi;
      --
      aUserName = ПолучитьИменаПользователей('ЕдиницаХранения');
      if (aUserName <> nil) then
        aResult = ПолучитьВыборку(aUserName, 'ЕдиницаХранения');
        РасшифроватьИмена(aResult, aUserFullName);
        for i = 1 .. LengthOfArray(aResult) do
          with Self.Record.Поступления.AddEx do
            ОператорИмя   = aResult[i,1] as String;
            Оператор      = aResult[i,2] as String;
            Введено       = aResult[i,3] as Integer;
            Редактировано = aResult[i,4] as Integer;
            ВсегоВведеноПоступлений       = ВсегоВведеноПоступлений       + aResult[i,3] as Integer;
            ВсегоРедактированоПоступлений = ВсегоРедактированоПоступлений + aResult[i,4] as Integer;
          end;
        od;
      fi;
      --
      aUserName = ПолучитьИменаПользователей('УчетныйДокумент');
      if (aUserName <> nil) then
        aResult = ПолучитьВыборку(aUserName, 'УчетныйДокумент');
        РасшифроватьИмена(aResult, aUserFullName);
        for i = 1 .. LengthOfArray(aResult) do
          with Self.Record.УчДок.AddEx do
            ОператорИмя   = aResult[i,1] as String;
            Оператор      = aResult[i,2] as String;
            Введено       = aResult[i,3] as Integer;
            Редактировано = aResult[i,4] as Integer;
            ВсегоВведеноУчДок       = ВсегоВведеноУчДок       + aResult[i,3] as Integer;
            ВсегоРедактированоУчДок = ВсегоРедактированоУчДок + aResult[i,4] as Integer;
          end;
        od;
      fi;
    fi;
  end;

  func ПолучитьИменаПользователей( КорИмяКлассаЗаписей :String ) :String[];
    var QResult :Variant[2];
    with Query.Create([РКП_СИС.ЛогРабот]) do
      Filter = ПолучитьФильтрЗапросаЛога(КорИмяКлассаЗаписей);
      QResult = CalcAggregates('GroupBy(CreateUser)') as Variant[2];
    end;
    if (QResult <> nil) then
      Result = QResult[1] as String[];
      SortArray(Result);
    fi;
  end;

  func ПолучитьПолныеИменаПользователей :String[2];
    var cResult :String[];
    with Query.Create([Kernel.Settings.User]) do
      Filter = 'isGroup=0';
      Select;
      while not Eof do
        cResult = [Current.Name, Current.FullName] as String[];
        AddInArray( Result, cResult);
        Next;
      od;
    end;
    SortArray(Result, [1]);
  end;

  func ПолучитьФильтрЗапросаЛога( КорИмяКлассаЗаписей :String ) :String;
    var aFlt :String[];
    AddInArray( aFlt, ПолучитьФильтрКомпетенций );
    AddInArray( aFlt, ПолучитьФильтрДат );
    AddInArray( aFlt, ПолучитьФильтрКлассаЗаписей(КорИмяКлассаЗаписей) );
    Result = MakeFilter( aFlt );
  end;

  func ПолучитьФильтрКомпетенций :String;
    var i :Integer;
    var aFlt :String[];
    for i = 1 .. LengthOfArray(КомпетенцииВОтчете) do
      AddInArray( aFlt, 'Match(Competencies, "*|' + Str(КомпетенцииВОтчете[i]) + '|*")' );
    od;
    Result = MakeFilter( aFlt, byOr );
  end;

  func ПолучитьФильтрДат :String;
    var aFlt :String[];
    AddInArray( aFlt, 'CreateDate>=' + Str(ДатаН) );
    AddInArray( aFlt, 'CreateDate<' + Str(ДатаК + 1) );
    Result = MakeFilter( aFlt );
  end;

  func ПолучитьФильтрКлассаЗаписей( КорИмяКлассаЗаписей :String ) :String;
    if (КорИмяКлассаЗаписей = 'Газета')             then Result = 'RClass="РКП_Газеты.Газета"';
    elsif (КорИмяКлассаЗаписей = 'НомерГазеты')     then Result = 'RClass="РКП_Газеты.НомерГазеты"';
    elsif (КорИмяКлассаЗаписей = 'ЕдиницаХранения') then Result = 'RClass="РКП_Газеты.ЕдиницаХранения"';
    elsif (КорИмяКлассаЗаписей = 'УчетныйДокумент') then Result = 'RClass="РКП_Газеты.УчетныйДокумент"';
    fi;
  end;

  func ПолучитьВыборку(aUserName :String[]; КорИмяКлассаЗаписей :String ) :Variant[2];  --[[UserName, nil, vCreateCount, vUpdateCount]]
    var vCreateCount, vUpdateCount :Integer;
    var cResult :Variant[];
    var cRec :РКП_СИС.ЛогРабот;
    var i :Integer;
    var rNsp :РКП_Газеты.Газета;
    if (aUserName <> nil) then
      with Query.Create([РКП_СИС.ЛогРабот]) do
        Filter = ПолучитьФильтрЗапросаЛога(КорИмяКлассаЗаписей);
        Select;
        while not Eof do
          cRec = Current as РКП_СИС.ЛогРабот;
          i = SearchInArray(aUserName, cRec.CreateUser,,true);
          if (i > 0) then
            cResult = Result[i] as Variant[];
            vCreateCount = cResult[3] as Integer;
            vUpdateCount = cResult[4] as Integer;
            if (КорИмяКлассаЗаписей = 'Газета')             then
              if (cRec.ActionType = wsRecCreated) and (cRec.StoredValL = false) then
                vCreateCount = vCreateCount + 1;
              fi;
              if (cRec.ActionType = wsRecUpdated) then
                vUpdateCount = vUpdateCount + 1;
              fi;
            elsif (КорИмяКлассаЗаписей = 'НомерГазеты')     then
              if (cRec.ActionType = wsAccepted) then
                vCreateCount = vCreateCount + 1;
              fi;
              if (cRec.ActionType = wsAcpUpdated) then
                vUpdateCount = vUpdateCount + 1;
              fi;
            elsif (КорИмяКлассаЗаписей = 'ЕдиницаХранения') then
              if (cRec.ActionType = wsAccepted) then
                vCreateCount = vCreateCount + cRec.StoredValI; -- суммируется количество номеров
              fi;
            elsif (КорИмяКлассаЗаписей = 'УчетныйДокумент') then
              if (cRec.ActionType = wsRecCreated) then
                vCreateCount = vCreateCount + 1;
              fi;
              if (cRec.ActionType = wsRecUpdated) then
                vUpdateCount = vUpdateCount + 1;
              fi;
            fi;
            cResult = [aUserName[i],nil,vCreateCount, vUpdateCount];
            Result[i] = cResult;
          fi;
          Next;
        od;
      end;
    end;
  end;

  proc РасшифроватьИмена(var aResult :Variant[2]; aUserFullName :String[2]);
    var vUserFullName :String;
    var i, j :Integer;
    for i = 1 .. LengthOfArray(aResult) do
      j = SearchInArray(aUserFullName, aResult[i,1] as String, [1], true);
      if (j > 0) then
        vUserFullName = aUserFullName[j,2];
      fi;
      if (vUserFullName <> nil) then
        aResult[i]  = [aResult[i,1], vUserFullName, aResult[i,3], aResult[i,4]];
      else
        aResult[i]  = [aResult[i,1], aResult[i,1], aResult[i,3], aResult[i,4]];
      fi;
    od;
  end;


end