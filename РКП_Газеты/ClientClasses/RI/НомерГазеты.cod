class inherited РКП_СИС.RI.intBase 'Интерфейс записи';

import РКП_СИС Classes Functions, StringsFunctions, Recs;

inclass public

  var ИмяПоляНеПрименяется :String = '';
  var ИмяПоляНаим          :String = 'Номер';

  func СвязанныйКлассЗаписей: Class СИС2.Базовая.БазоваяЗапись;
    Result = РКП_Газеты.НомерГазеты;
  end;

  func Create: РКП_Газеты.RI.НомерГазеты;
    Result = inherited Create;
    Result.Record = РКП_Газеты.НомерГазеты.Create;
  end;

  func ОткрытьПоЗаписи synonym OpenRecord(locRecord: РКП_Газеты.НомерГазеты): РКП_Газеты.RI.НомерГазеты;
    Result = inherited Create;
    Result.Record = locRecord;
  end;

  func БланкРедакторПоУмолчанию: Class BlankForm;
    Result = УчетГазет.редНомерГазеты;
  end;

  func КартотекаПоУмолчанию: Class CardForm;
    Result = nil;
  end;

  proc ИнициализироватьИнтерфейс synonym InitInterface;
    var локПолнИмя :String;
    var локМетод :MethodInfo;
    inherited InitInterface;
    локПолнИмя = 'РКП_Газеты.RI.НомерГазеты.УдалениеИстории';
    локМетод = СИС2.ФункцииРТТИ.ПолучитьИнфоМетодаПоПолномуИмениМетода(локПолнИмя);
    СобытиеПередУдалением.AddMethod(локМетод);
    локПолнИмя = 'РКП_Газеты.RI.НомерГазеты.КоррЛог';
    локМетод = СИС2.ФункцииРТТИ.ПолучитьИнфоМетодаПоПолномуИмениМетода(локПолнИмя);
    СобытиеПередУдалением.AddMethod(локМетод);
  end;

  func УдалениеИстории(локПарам[] :Variant) :Logical;
    var vRec :РКП_Газеты.НомерГазеты;
    var Q :Query;
    vRec = локПарам[2] as РКП_Газеты.НомерГазеты;
    if (vRec <> nil) then
      Q = Query.Create([РКП_Газеты.ИсторияГазеты]);
      Q.Filter = 'СНомера=' + vRec.DocIDStr;
      Q.Select;
      РКП_СИС.Recs.DeleteAllRecords(Q);
    fi;
  end;

  func КоррЛог(локПарам[] :Variant) :Logical; -- удаление записей из лога
    var vRec :РКП_Газеты.НомерГазеты;
    vRec = локПарам[2] as РКП_Газеты.НомерГазеты;
    if (vRec <> nil) then
      Self.ClearWorkLogExt(vRec, false, wsRecCreated);
    fi;
  end;

inobject public

  Record: РКП_Газеты.НомерГазеты;

  proc ИнициализироватьПоУмолчанию synonym InitByDefault;
    Init;
  end;

  proc Инициализировать synonym Init;
    Assert(Record.State = Kernel.Record.Created);
  end;


  proc Записать synonym Post( аДиалоговыйРежим :Logical = False );
    if ПроверитьУникальность then
      РегистрацияНомера;
      SetWorkLog(wsRecCreated, wsRecUpdated);
      SetWorkLog(wsAccepted, wsAcpUpdated);
     inherited Post(аДиалоговыйРежим);
      if (Record.Газета.Прекращено <> Record.ПрекращениеИздания) then
        Record.Газета.Прекращено = Record.ПрекращениеИздания;
        if (Record.ПрекращениеИздания) then
          Record.Газета.НомерПоследнегоНомера        = Record.Номер;
          Record.Газета.ВалПоследнегоНомера          = Record.ВаловыйНомер;
          Record.Газета.ДатаВыходаПоследнегоНомера   = Record.ДатаВыхода;
          Record.Газета.ТочностьДатыПоследнегоНомера = Record.ТочностьДатыВыхода;
        else
          Record.Газета.НомерПоследнегоНомера        = nil;
          Record.Газета.ВалПоследнегоНомера          = nil;
          Record.Газета.ДатаВыходаПоследнегоНомера   = nil;
          Record.Газета.ТочностьДатыПоследнегоНомера = nil;
        fi;
      fi;
      RecordPostIfNeed(Record.Газета);
      if (Record.ПрекращениеИздания) then
        -- снятие признака прекращения с ранее прекращенных номеров
        with Query.Create([РКП_Газеты.НомерГазеты])  do
          Filter = 'Газета=' + Record.Газета.DocIDStr + ' and isGroup=0 and DocId<>' + Str(Record.DocId);
          Select;
          while not Eof do
            if Current.ПрекращениеИздания then
              Current.ПрекращениеИздания = false;
              RecordPostIfNeed(Current);
            fi;
            Next;
          od;
        end;
      fi;
      ---
    fi;
  end;

  --= InObject методы для реализации функционала сохранения данных в WorkLog =--

  func ContentValidToWorkLog(byWorkState :tWorkState) :Logical; -- Содержимое записи валидно для принятия к учету как единица рабочего процесса
    if (byWorkState in [wsRecCreated, wsRecUpdated]) then
      Result = (Record.ФункцияГруппы = 0);
    elsif (byWorkState in [wsAccepted, wsAcpUpdated]) then
      Result = (not Record.НеПолучен) and (Record.ФункцияГруппы = 0);
    fi;
  end;

  func CreateDateForWorkLog (WorkState :tWorkState; byCurrentUsers :Logical) :Date; -- Дата, когда запись считается созданной и принимается к учету как единица рабочего процесса
    var dt :Date;
    if (WorkState in [wsRecCreated, wsRecUpdated]) then
      Result = inherited CreateDateForWorkLog (WorkState, byCurrentUsers);
    elsif (WorkState in [wsAccepted, wsAcpUpdated]) then
      if byCurrentUsers then
        if (Self.Record.UpdateUser = SessionInfo.UserName) then
          dt = Self.Record.ДатаПринятияНаХранение;
          Result = CreateDate(Day(dt), Mon(dt), Year(dt));
        fi;
      else
        dt = Self.Record.ДатаПринятияНаХранение;
        Result = CreateDate(Day(dt), Mon(dt), Year(dt));
      fi;
    fi;
  end;

  ----------------------------------------------------------------------------

  proc РегистрацияНомера;
   if (Record.ПринялНаХранение = nil) and (Record.ДатаПринятияНаХранение = nil) then
     if not (Record.НеПолучен) then
       Record.ПринялНаХранение = SessionInfo.UserRecord.Name;
       Record.ДатаПринятияНаХранение = Today;
     fi;
   fi;
   if (Record.НеПолучен) then
     Record.ПринялНаХранение = nil;
     Record.ДатаПринятияНаХранение = nil;
     Record.Тираж = nil;
   fi;
  end;

  func ПроверитьУникальность: Logical;
    Return ПроверитьУникальностьВыпуска(Record);
  end;

  proc ВыполнитьУдаление synonym DoDelete( const aCheckRefs :Logical );
    ClearWorkLog(wsRecCreated, false);
    inherited DoDelete(aCheckRefs);
  end;

inclass public

  func ПроверитьУникальностьВыпуска (R :РКП_Газеты.НомерГазеты; ModFieldName :String = nil; Value :Variant = nil): Logical;
    var vFlt :String;
    var ТекстСообщения :String;
    var vFoundRecord :РКП_Газеты.НомерГазеты;
    var vChoice :Integer;
    if (ModFieldName <> nil) and not (ModFieldName in ['СерияНумерации', 'Номер', 'НеПолучен','ЛожныйНомер']) then -- проверка не имеет смысла
      Return true;
    elsif (ModFieldName = nil) then -- проверка перед сохранением (все значения введены)
      with FltMaker.CreateExt do
        AddCondition( 'isGroup=0' );
        AddCondition( 'DocId<>' + Str(R.DocId) );
        AddCondition( 'Газета=' + R.Газета.DocIDStr );
        AddCondition( 'ГодВыпуска=' + Str(R.ГодВыпуска) );
        AddCondition( 'not ЛожныйНомер' );
        AddCondition( 'СерияНумерации=' + Str(R.СерияНумерации) );
        AddCondition( 'Номер="' + Str(R.Номер) + '"' );
        CompressConditionsToOne;
        AddCondition( 'not(СозданОЛГС and НеПолучен)' );
        vFlt = GetFilter;
      end;
      vFoundRecord = РКП_СИС.Recs.FindRecord(РКП_Газеты.НомерГазеты, vFlt);
      Result = (vFoundRecord  = nil);
    elsif (ModFieldName <> nil) and (ModFieldName in ['СерияНумерации', 'Номер', 'НеПолучен','ЛожныйНомер']) then -- проверка имеет смысл для проверяемого значения
      if (ModFieldName = 'СерияНумерации') then
        with FltMaker.CreateExt do
          AddCondition( 'isGroup=0' );
          AddCondition( 'DocId<>' + Str(R.DocId) );
          AddCondition( 'Газета=' + R.Газета.DocIDStr );
          AddCondition( 'ГодВыпуска=' + Str(R.ГодВыпуска) );
          AddCondition( 'not ЛожныйНомер' );
          AddCondition( 'СерияНумерации=' + Str(Value as Integer) );
          AddCondition( 'Номер="' + Str(R.Номер) + '"' );
          CompressConditionsToOne;
          AddCondition( 'not(СозданОЛГС and НеПолучен)' );
          vFlt = GetFilter;
        end;
        vFoundRecord = РКП_СИС.Recs.FindRecord(РКП_Газеты.НомерГазеты, vFlt);
        Result = (vFoundRecord  = nil);
      elsif (ModFieldName = 'Номер') then
        with FltMaker.CreateExt do
          AddCondition( 'isGroup=0' );
          AddCondition( 'DocId<>' + Str(R.DocId) );
          AddCondition( 'Газета=' + R.Газета.DocIDStr );
          AddCondition( 'ГодВыпуска=' + Str(R.ГодВыпуска) );
          AddCondition( 'not ЛожныйНомер' );
          AddCondition( 'СерияНумерации=' + Str(R.СерияНумерации) );
          AddCondition( 'Номер="' + (Value as String) + '"' );
          CompressConditionsToOne;
          AddCondition( 'not(СозданОЛГС and НеПолучен)' );
          vFlt = GetFilter;
        end;
        vFoundRecord = РКП_СИС.Recs.FindRecord(РКП_Газеты.НомерГазеты, vFlt);
        Result = (vFoundRecord  = nil);
      elsif (ModFieldName = 'НеПолучен') then
        with FltMaker.CreateExt do
          AddCondition( 'isGroup=0' );
          AddCondition( 'DocId<>' + Str(R.DocId) );
          AddCondition( 'Газета=' + R.Газета.DocIDStr );
          AddCondition( 'ГодВыпуска=' + Str(R.ГодВыпуска) );
          AddCondition( 'not ЛожныйНомер' );
          AddCondition( 'СерияНумерации=' + Str(R.СерияНумерации) );
          AddCondition( 'Номер="' + Str(R.Номер) + '"' );
          CompressConditionsToOne;
          AddCondition( 'not(СозданОЛГС and ' + Str(Value as Logical) + ')' );
          vFlt = GetFilter;
        end;
        vFoundRecord = РКП_СИС.Recs.FindRecord(РКП_Газеты.НомерГазеты, vFlt);
        Result = (vFoundRecord  = nil);
      elsif (ModFieldName = 'ЛожныйНомер') then
        with FltMaker.CreateExt do
          AddCondition( 'isGroup=0' );
          AddCondition( 'DocId<>' + Str(R.DocId) );
          AddCondition( 'Газета=' + R.Газета.DocIDStr );
          AddCondition( 'ГодВыпуска=' + Str(R.ГодВыпуска) );
          AddCondition( 'not ' + Str(Value as Logical) );
          AddCondition( 'СерияНумерации=' + Str(R.СерияНумерации) );
          AddCondition( 'Номер="' + Str(R.Номер) + '"' );
          CompressConditionsToOne;
          AddCondition( 'not(СозданОЛГС and НеПолучен)' );
          vFlt = GetFilter;
        end;
        vFoundRecord = РКП_СИС.Recs.FindRecord(РКП_Газеты.НомерГазеты, vFlt);
        Result = (vFoundRecord  = nil);
      fi;
    fi;
    if (not Result) then
      if (ModFieldName = 'СерияНумерации') then
        if ((Value as Integer) = 0) then
          ТекстСообщения = Trim(R.Номер) + ' [' + Str(R.ГодВыпуска) + ']';
        else
          ТекстСообщения = Trim(R.Номер) + '(' + Str((Value as Integer)) + ') [' + Str(R.ГодВыпуска) + ']';
        fi;
      elsif (ModFieldName = 'Номер') then
        if (R.СерияНумерации = 0) then
          ТекстСообщения = Trim((Value as String)) + ' [' + Str(R.ГодВыпуска) + ']';
        else
          ТекстСообщения = Trim((Value as String)) + '(' + Str(R.СерияНумерации) + ') [' + Str(R.ГодВыпуска) + ']';
        fi;
      elsif (ModFieldName = nil) then -- проверка перед сохранением (все значения введены)
        if (R.СерияНумерации = 0) then
          ТекстСообщения = Trim(R.Номер) + ' [' + Str(R.ГодВыпуска) + ']';
        else
          ТекстСообщения = Trim(R.Номер) + '(' + Str(R.СерияНумерации) + ') [' + Str(R.ГодВыпуска) + ']';
        fi;
      fi;
      if vFoundRecord.СозданОЛГС then
        ТекстСообщения = ТекстСообщения + ' (Л Г С)';
      fi;
      if R.ЛожныйНомер then
        if (vFoundRecord.ДатаПринятияНаХранение <> nil) then
          ТекстСообщения = 'Номер газеты ' + ТекстСообщения + ' был внесен в базу данных ранее (' + Str(vFoundRecord.ДатаПринятияНаХранение) + ').';
        else
          ТекстСообщения = 'Номер газеты ' + ТекстСообщения + ' был внесен в базу данных ранее.';
        fi;
        vChoice = Enquiry('Подтверждение',
                          ТекстСообщения + Br +
                          'Всё равно сохранть?',
                          ['Да', 'Нет']);


        if (vChoice = 1) then
          Return true;
        fi;
      else
        if (vFoundRecord.ДатаПринятияНаХранение <> nil) then
          ТекстСообщения = 'Номер газеты ' + ТекстСообщения + ' был внесен в базу данных ранее (' + Str(vFoundRecord.ДатаПринятияНаХранение) + ').';
        else
          ТекстСообщения = 'Номер газеты ' + ТекстСообщения + ' был внесен в базу данных ранее.';
        fi;
        Message(ТекстСообщения);
      fi;
    fi;
  end;

  func ПолученоЕдХран (R :РКП_Газеты.НомерГазеты) :Integer;
    with Query.Create([РКП_Газеты.ЕдиницаХранения]) do
      Filter = 'НомерГазеты=' + Str(R.DocIDStr);
      Return Int(CalcAggregates('Sum(Количество)'));
    end;
  end;

inobject public

  proc ОбновитьКоличествоЕдХран;
    Record.ПринятоЭкземпляров = ПолученоЕдХран(Record);
    Post;
  end;

  func ПолучитьЕдХран (var КолЭкзВсего :Integer) :РКП_Газеты.ЕдиницаХранения[];
    var cRec :РКП_Газеты.ЕдиницаХранения;
    with Query.Create([РКП_Газеты.ЕдиницаХранения]) do
      Filter = 'НомерГазеты=' + Str(Self.Record.DocIDStr);
      Order = 'ДатаПоступления';
      Select;
      while not Eof do
        cRec =  Current as РКП_Газеты.ЕдиницаХранения;
        AddInArray( Result, cRec );
        КолЭкзВсего = КолЭкзВсего + cRec.Количество;
        Next;
      od;
    end;
  end;



end