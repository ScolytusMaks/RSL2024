class inherited ћашина–еквизитов.Ѕазовые.карт—»нтерфейсом "√азеты и ћѕ";

import – ѕ_—»— Classes Profile, StringsFunctions, StdCode, Functions, Recs, FilterMaker;

--{{ 2_—войства
inclass public

  var  ласс»нтерфейса :Class ћашина–еквизитов.Ѕазовые.инт«апись = RI.√азета;

inclass private

  stored var х¬ариантѕростого‘ильтра  :Integer;
  stored var х¬ариантѕростого‘ильтра2 :Integer;
  var »мена лючевых—толбцов :String[] := ['–егЌомер','ISSN','Ќазваниеќсн','ЌазваниеЌацяз','Ќазвание»няз','Ќазвание»няз','ѕодзаголовок','ћеста»здани€—тр']; -- столбцы, нобходимые дл€ идентификации издани€
  var »мена—толбцовЋѕѕ»     :String[] := ['√одЋетописи', 'Ќомер¬Ћетописи','«апись¬Ћетописи','ѕризнакќтсылки','Ќазваниеќсн','ѕодзаголовок']; -- столбцы дл€ идентификации издани€ в картотеке формировани€ Ћѕѕ»

inobject public

  var »гнорировать’ранимые—войства   :Logical;

inobject private

  stored var ¬ариантѕростого‘ильтра  :Integer;
  stored var ¬ариантѕростого‘ильтра2 :Integer;
  var ‘рагментЌазвани€     :String;
  var ‘рагментѕодзаголовка :String;
  var ‘рагмент–егЌомера    :String;

  var —мена          :– ѕ_—»—.—мена := ѕолучить«апись—мены;
  var Ќачало—мены    :Date          := if((—мена <> nil), —мена.CreateDate, nil);
  var ќператор       :String        := if((SessionInfo.UserRecord <> nil), (SessionInfo.UserRecord as Kernel.Settings.User).FullName, nil);
  var Ќомеров«а—мену :Integer;

  var UpdateDate     :Date;
  var UpdateUser     :String;
  var CreateDate     :Date;
  var CreateUser     :String;

  var фрейм»нформаци€ќ«аписи :TemplateFrame;
  var фрейм»нформаци€ќ—мене  :TemplateFrame;
  var фрейм—ервис :TemplateFrame;
  var секц»нфќ«аписи1 :TemplateSection;
  var секц»нфќ«аписи2 :TemplateSection;
  var секц»нфќ—мене1  :TemplateSection;
  var секц»нфќ—мене2  :TemplateSection;
  var секц»нфќ—мене3  :TemplateSection;
  var кл”пр»нфќ«аписи :TemplateCell := if(секц»нфќ«аписи1 <> nil, секц»нфќ«аписи1.Cell[1,1], nil);
  var кл”пр»нфќ—мене  :TemplateCell := if(секц»нфќ—мене1<> nil, секц»нфќ—мене1.Cell[1,1], nil);

  var PageDef    :Image;
  var PageBlack  :Image;
  var PageYellow :Image;
  var PageBlue   :Image;
  var PageRed    :Image;

--}}

-- 2_ онструкторы, визуализаторы0. --

inclass public

  func ¬ыполнить¬ыбор_ќтсылки (var лок–езультат¬ыбора: – ѕ_√азеты.√азета; лок¬ызывающа€ :– ѕ_√азеты.√азета; лок‘рагментЌазвани€ :String = nil): Integer;
    var locForm: ”чет√азет.карт√азеты;
    locForm = ”чет√азет.карт√азеты.Create;
    locForm.”далитьЌеключевые—толбцы;
    locForm.SetField('«апретить_ƒобавление', true);
    locForm.SetField('«апретить_ƒобавление√рупп', true);
    locForm.SetField('«апретить_ƒублирование', true);
    locForm.SetField('«апретить_”даление', true);
    locForm.SetField('«апретить_ѕеренос', true);
    locForm.SetField('«апретить_ опирование', true);
    locForm.SetField('«апретить_ѕреобразование', true);
    locForm.‘рагментЌазвани€ = лок‘рагментЌазвани€;
    locForm.ƒополнительный‘ильтр = 'not ѕризнакќтсылки and DocId<>' + Str(лок¬ызывающа€.DocId);
    locForm.секц»нфќ—мене1.Visible = false;
    if CmOk = locForm.ShowEx(лок–езультат¬ыбора, nil, Kernel.Window.ModalWindow) then
      Return CmOk;
    fi;
  end;

inobject private

-- 2_ќбработчики событий шаблона0. --

  proc шаблон_ѕри—оздании(Context :Variant);
    inherited шаблон_ѕри—оздании(Context);
    Self.Cardfile.CanInsert = (FullAccess or ORGPAccess);
    Self.Cardfile.CanDelete = (FullAccess or ORGPAccess);
    Self.Cardfile.CanCopy = false;
    PageDef    = Image.Create; PageDef.LoadFromFile('%Projects%\– ѕ_—»—\Attachments\Icons\PageDef.ico');
    PageBlack  = Image.Create; PageBlack.LoadFromFile('%Projects%\– ѕ_—»—\Attachments\Icons\PageBlack.ico');
    PageYellow = Image.Create; PageYellow.LoadFromFile('%Projects%\– ѕ_—»—\Attachments\Icons\PageYellow.ico');
    PageBlue   = Image.Create; PageBlue.LoadFromFile('%Projects%\– ѕ_—»—\Attachments\Icons\PageBlue.ico');
    PageRed    = Image.Create; PageRed.LoadFromFile('%Projects%\– ѕ_—»—\Attachments\Icons\PageRed.ico');
    if OPPIAccess then
      ”далитьЌеключевые—толбцы;
      Template.HelpContext =  '– ѕ_√азеты.–√Ѕ.”чет‘актическихѕоступлений.–еестр√азет.htm';
    else
      Template.HelpContext =  '– ѕ_√азеты.–√Ѕ.–егистраци€.–еестр√азет.htm';
    fi;
    фрейм—ервис.Visible = DevAccess;
    Self.CanHideTemplate = true;
  end;

  proc шаблон_ѕриќткрытии(Create :Logical);
    if (кл”пр»нфќ«аписи <> nil) then
      кл”пр»нфќ«аписи.Contents = SymbolCollapsed;
    fi;
    if (кл”пр»нфќ—мене <> nil) then
      кл”пр»нфќ—мене.Contents = SymbolCollapsed;
    fi;
    if not »гнорировать’ранимые—войства then
      ¬ариантѕростого‘ильтра  = х¬ариантѕростого‘ильтра;
      ¬ариантѕростого‘ильтра2 = х¬ариантѕростого‘ильтра2;
    else
      Self.Window.Caption = '√азеты и ћѕ (фильтр)';
    fi;
    inherited шаблон_ѕриќткрытии(Create);
    SetFindMaskFormat('Ќазваниеќсн');
    SetFindMaskFormat('ЌазваниеЌацяз');
    SetFindMaskFormat('Ќазвание»няз');
    SetFindMaskFormat('ѕодзаголовок');
    SetFindMaskFormat('E_mail');
    SetFindMaskFormat('HTTP');
    ”становитьќграничениећинЎирины—толбцов;
    »зменить»конкуќкна;
    —мена = ѕолучить«апись—мены;
  end;

  func шаблон_ѕеред«акрытием(ModalResult :Integer) :Logical;
    х¬ариантѕростого‘ильтра  = ¬ариантѕростого‘ильтра;
    х¬ариантѕростого‘ильтра2 = ¬ариантѕростого‘ильтра2;
    Result = inherited шаблон_ѕеред«акрытием(ModalResult);
  end;


-- 2_ќбработчики событий клеток шаблона0. --

  func ѕоле_ѕриЌажатии_‘ильтр(Cell :TemplateCell; Action :Template.ClickTypes) :Logical;
    var r: Integer;
    r = Cell.Row;
    if (Cell.Contents = '¬ариантѕростого‘ильтра') then
      ¬ариантѕростого‘ильтра = (r - 1);
    elsif (Cell.Contents = '¬ариантѕростого‘ильтра2') then
      ¬ариантѕростого‘ильтра2 = (r - 1);
    fi;
    ќбновить‘ильтр;
  end;

  func ѕоле_ѕриЌажатии_ƒоп»нфо(Cell :TemplateCell; Action :Template.ClickTypes) :Logical;
    if (Cell in [кл”пр»нфќ«аписи, кл”пр»нфќ—мене]) then
      if Cell.Contents = SymbolCollapsed then
        Cell.Contents = SymbolExpanded;
      elsif Cell.Contents = SymbolExpanded then
        Cell.Contents = SymbolCollapsed;
      fi;
      ћодифицироватьЎаблон;
      if Cell.Contents = SymbolExpanded then
        ¬ычислить„ислоЌомеров«а—мену;
      fi;
    fi;
  end;

  func ѕоле_ѕриЌажатии_ѕрин€то«аѕериод(Cell :TemplateCell; Action :Template.ClickTypes) :Logical;
    if true in [DevAccess,AdmAccess,FullAccess,ORGPAccess] then
      – ѕ_√азеты.”чет√азет.ќтчеты.блѕротокол¬вода—отрќ–√ѕ.ShowFormEx( , Kernel.Window.ModalWindow);
    elsif OPPIAccess then
      – ѕ_√азеты.”чет√азет.ќтчеты.блѕротокол¬вода—отрќѕѕ».ShowFormEx( , Kernel.Window.ModalWindow);
    fi;
  end;

  proc ѕоле_‘ильтр_ѕри¬ыходе(Cell :TemplateCell; Index :Integer);
    ќбновить‘ильтр;
  end;

  func ѕоле_ѕри¬ыводе_‘ильтр(Cell :TemplateCell; Value :Variant; Action :Template.OutputTypes; var Format :String) :Variant;
    var r: Integer;
    r = Cell.Row;
    if (Cell.Contents = '¬ариантѕростого‘ильтра') then
      Cell.Caption = if( (r - 1) = ¬ариантѕростого‘ильтра, 'l', '');
    elsif (Cell.Contents = '¬ариантѕростого‘ильтра2') then
      Cell.Caption = if( (r - 1) = ¬ариантѕростого‘ильтра2, 'l', '');
    fi;
  end;


-- 2_ќбработчики событий прочих объектов шаблона0. --

  proc кн”далить_ѕриЌажатии(Sender :Button);
    --var Ќазваниегазеты :string;
    --Ќазваниегазеты = CardFile.Current.Ќазваниеќсн;
    if (ParentFrame <> nil) then
      if (Window.CurrentObject = nil) or (Window.CurrentObject in [Window.CardFile, Window.CardfileSubtable, Window.Template]) then
        Window.CurrentObject = Window.CardFile;
      else
        Window.CurrentObject = Window.CardfileSubtable;
      fi;
    fi;
    --if ѕроверить√азетуƒо”далени€(CardFile.Current) then
      ExecuteCommand('Kernel.Card.Run.DeleteRec');
    --  Message("√азета <" + Ќазваниегазеты + "> успешно удалена!");
    --fi;
  end;

  proc кнќбработать_ѕриЌажатии(Sender :Button);
    var k, kk :Integer;
    var ri :RI.√азета;
    with Query.Create([– ѕ_√азеты.√азета]) do
      kk = Count;
      Select;
      while not Eof do
        ri = – ѕ_√азеты.RI.√азета.OpenRecord(Current);
        ri.ќбновитьѕол€»нфо;
        – ѕ_—»—.Recs.RecordPostIfNeed(Current);
        k = k + 1;
        Hint('¬ыполнение (' + Current.Ќазваниеќсн + ')...', k, kk);
        Next;
      od;
    end;
  end;

  proc кн»мпорт_ѕриЌажатии(Sender :Button);
    var vFileName, vLine, vCode:String;
    var vFileCsv :TextFile;
    var aValue :String[];
    var rNsp :√азета;
    if (cmOk = ChooseFile(vFileName, 'ƒанные дл€ загрузки', 'csv|*.csv')) then
      vFileCsv = TextFile.Create(vFileName, fmOpenRead);
      ClearTrace;
      vFileCsv.ReadLn;
      while not vFileCsv.Eof do
        vLine = vFileCsv.ReadLn;
        SplitString(vLine, ';', aValue);
        vCode = Trim(aValue[2]);
        rNsp = FindRecord(√азета, 'ExtId="' + vCode + '"');
        if (rNsp = nil) then
          Trace('Ќе найдена запись ExtId="' + vCode + '"');
        else
          rNsp. омплект–√Ѕ = (Trim(aValue[3]) <> nil);
          RecordPostIfNeed(rNsp);
        fi;
      od;
    fi;
  end;



-- 2_ќбработчики событий картотеки0. --

  proc картотека_ѕриѕеремещении(Record :Record);
    inherited картотека_ѕриѕеремещении(Record);
    ¬ычислить„ислоЌомеров«а—мену;
    if (Record <> nil) then
      UpdateDate = Record.UpdateDate;
      UpdateUser = Record.UpdateUser;
      CreateDate = Record.CreateDate;
      CreateUser = Record.CreateUser;
    else
      UpdateDate = nil;
      UpdateUser = nil;
      CreateDate = nil;
      CreateUser = nil;
    fi;
  end;

  func картотека_ѕриќткрытииЅланка(Action :Integer; Record :Record) :Logical;
    Result = inherited картотека_ѕриќткрытииЅланка(Action, Record);
    ‘рагментЌазвани€ = nil;
    ‘рагментѕодзаголовка = nil;
    ќбновить‘ильтр;
  end;

  func картотека_ѕеред»зменением(Action :Cardfile.ModifyActions; Rec :Record; Group :Record; var AskConfirm :Logical) :Logical;
    Result = inherited картотека_ѕеред»зменением(Action, Rec, Group, AskConfirm);
    if Result then
      if (Action = Cardfile.DeleteRecord) then -- реакци€ на удаление
        if (Record <> nil)  and (Cardfile.SelectedCount = 0) then -- текуща€ запись одна
          Result = RI.√азета.OpenRecord(Rec).”даление¬озможно;

        elsif (Record = nil)  and (Cardfile.SelectedCount > 0) then -- выделено несколько записей
          Message('ѕожалуйста, снимите выделение нескольких записей. ћассовое удаление записей в этой форме не предусмотрено.');
        fi;
      else
        Return true;
      fi;
    fi;
  end;

  proc картотека_ѕри–исовании—троки(Rec :Record; Selected :Logical; var Color :Integer; Image :Image);
    Rec = Rec as – ѕ_√азеты.√азета;
    if Rec.ѕрекращено          then Image.Assign(PageBlack);
    elsif Rec.ѕризнакќтсылки   then Image.Assign(PageYellow);
    elsif not Rec. омплект–√Ѕ  then Image.Assign(PageRed);
    else                            Image.Assign(PageDef);
    fi;
  end;


-- 2_ќбработчики столбцов (полей) картотеки0. --

  func картѕоле_ѕри¬ыводе_ћесто»здани€(Column :CardfileColumn; Rec :– ѕ_√азеты.√азета; Action :Template.OutputTypes; var Format :String) :Variant;
    var vCount :Integer;
    if Column.Visible and (Action = Template.Output) then
      vCount = Rec.ћеста»здани€.Count;
      if (vCount = 1) then
        Return Rec.ћеста»здани€.Items[1].ћесто»здани€.Ќаим;
      elsif (vCount = 2) then
        Return Rec.ћеста»здани€.Items[1].ћесто»здани€.Ќаим + " ; " +
               Rec.ћеста»здани€.Items[2].ћесто»здани€.Ќаим;
      elsif (vCount >= 3) then
        Return Rec.ћеста»здани€.Items[1].ћесто»здани€.Ќаим + " ; " +
               Rec.ћеста»здани€.Items[2].ћесто»здани€.Ќаим + " ; " +
               Rec.ћеста»здани€.Items[3].ћесто»здани€.Ќаим;
      fi;
    fi;
  end;

  func картѕоле_ѕри¬ыводе_язык»здани€(Column :CardfileColumn; Rec :Record;Action :Template.OutputTypes;var Format :String) :Variant;
    var vCount :Integer;
    if Column.Visible and (Action = Template.Output) then
      vCount = Rec.языки.Count;
      if (vCount = 1) then
        Result = Rec.языки.Items[1].язык.Ќаим;
      elsif (vCount = 2) then
        Result = Rec.языки.Items[1].язык.Ќаим + " ; " +
                 Rec.языки.Items[2].язык.Ќаим;
      elsif (vCount >= 3 ) then
        Result = Rec.языки.Items[1].язык.Ќаим + " ; " +
                 Rec.языки.Items[2].язык.Ќаим + " ; " +
                 Rec.языки.Items[3].язык.Ќаим;
      fi;
    fi;
  end;

  func картѕоле_ѕри¬ыводе_„итательскийјдрес(Column :CardfileColumn; Rec :Record;Action :Template.OutputTypes;var Format :String) :Variant;
    var vCount :Integer;
    if Column.Visible and (Action = Template.Output) then
      vCount = Rec.„ј÷Ќ.Count;
      if (vCount = 1) then
        Result = Rec.„ј÷Ќ.Items[1].„ј÷Ќ.Ќаим;
      elsif (vCount = 2) then
        Result = Rec.„ј÷Ќ.Items[1].„ј÷Ќ.Ќаим + " ; " +
                 Rec.„ј÷Ќ.Items[2].„ј÷Ќ.Ќаим;
      elsif (vCount >= 3) then
        Result = Rec.„ј÷Ќ.Items[1].„ј÷Ќ.Ќаим + " ; " +
                 Rec.„ј÷Ќ.Items[2].„ј÷Ќ.Ќаим + " ; " +
                 Rec.„ј÷Ќ.Items[3].„ј÷Ќ.Ќаим;
      fi;
    fi;
  end;

  func картѕоле_ѕри¬ыводе_“ематика(Column :CardfileColumn; Rec :Record;Action :Template.OutputTypes;var Format :String) :Variant;
    var vCount :Integer;
    if Column.Visible and (Action = Template.Output) then
      vCount = Rec.“ематики.Count;
      if (vCount = 1) then
        Result = Rec.“ематики.Items[1].“ематика.Ќаим;
      elsif (vCount = 2) then
        Result = Rec.“ематики.Items[1].“ематика.Ќаим + " ; " +
                 Rec.“ематики.Items[2].“ематика.Ќаим;
      elsif (vCount >= 3) then
        Result = Rec.“ематики.Items[1].“ематика.Ќаим + " ; " +
                 Rec.“ематики.Items[2].“ематика.Ќаим + " ; " +
                 Rec.“ематики.Items[3].“ематика.Ќаим;
      fi;
    fi;
  end;

  func картѕоле_ѕри¬ыводе_ѕоследнийѕолученныйЌомер(Column :CardfileColumn; Rec :Record;Action :Template.OutputTypes;var Format :String) :Variant;
    var RecNom  :Record;
    if Column.Visible and (Action = Template.Output) then
      RecNom = – ѕ_√азеты.—тат.ѕоследнийѕолученныйЌомер(Rec);
      if (RecNom <> nil) then
        Return BiblioRecord.ќписаниеЌомера(RecNom);
      fi;
    fi;
  end;


-- 2_ƒополнительные команды0. --


-- 2_¬спомогательные методы0. --

  func ѕолучить‘ильтр артотеки (var locTreeFilter :String = nil) :String;
    var aFlt :String[];
    AddInArray( aFlt, Self.ƒополнительный‘ильтр );
    AddInArray( aFlt, ѕолучить‘ильтр_ѕоЌазванию );
    AddInArray( aFlt, ѕолучить‘ильтр_ѕоѕодзаголовку );
    AddInArray( aFlt, ѕолучить‘ильтр_ѕо–егЌомеру );
    Result = MakeFilter(aFlt);
  end;

  func ѕолучить‘ильтр_ѕоЌазванию :String;
    if (‘рагментЌазвани€ <> nil) then
      if (¬ариантѕростого‘ильтра = 1) then
        Return 'Match(Ќазваниеќсн,"*' + ‘рагментЌазвани€ + '*")';
      else
        Return 'Match(Ќазваниеќсн,"' + ‘рагментЌазвани€ + '*")';
      fi;
    fi;
  end;

  func ѕолучить‘ильтр_ѕоѕодзаголовку :String;
    if (‘рагментѕодзаголовка <> nil) then
      if  (¬ариантѕростого‘ильтра2 = 1) then
        Return 'Match(ѕодзаголовок,"*' + ‘рагментѕодзаголовка + '*")';
      else
        Return 'Match(ѕодзаголовок,"' + ‘рагментѕодзаголовка + '*")';
      fi;
    fi;
  end;

  func ѕолучить‘ильтр_ѕо–егЌомеру :String;
    if (‘рагмент–егЌомера <> nil) then
      Return 'Match(–егЌомер,"*' + ‘рагмент–егЌомера + '*")';
    fi;
  end;

  proc ¬ычислить„ислоЌомеров«а—мену;
    if (кл”пр»нфќ—мене.Contents = SymbolExpanded) then
      if (SessionInfo.UserRecord <> nil) then
        if OPPIAccess then
          Ќомеров«а—мену = – ѕ_√азеты.—тат.ѕрин€то≈д’ранени€«а—мену(SessionInfo.UserRecord.Name ,Today);
        else
          Ќомеров«а—мену = – ѕ_√азеты.—тат.ѕрин€тоЌомеров«а—мену(SessionInfo.UserRecord.Name ,Today);
        fi;
      fi;
    fi;
  end;

  proc ћодифицироватьЎаблон;
    секц»нфќ«аписи2.Visible = (кл”пр»нфќ«аписи.Contents = SymbolExpanded);
    секц»нфќ—мене2.Visible  = (кл”пр»нфќ—мене.Contents = SymbolExpanded);
    секц»нфќ—мене3.Visible  = (кл”пр»нфќ—мене.Contents = SymbolExpanded);
  end;

  -- ѕоиск и при необходимости - создание
  -- записи с информацией о смене
  func ѕолучить«апись—мены :– ѕ_—»—.—мена;
    var UN :String;
    var aFlt :String[];

    func —мен¬√оду :Integer;
      with Query.Create([– ѕ_—»—.—мена]) do
        Filter = 'CreateUser="' + UN + '" and Year(CreateDate)=' + Str(Year(Today));
        Return Count;
      end;
    end;

    if (SessionInfo.UserRecord <> nil) then
      UN = (SessionInfo.UserRecord as Kernel.Settings.User).Name;
      ќператор = (SessionInfo.UserRecord as Kernel.Settings.User).FullName;
      AddInArray( aFlt, 'CreateUser="' + UN + '"');
      AddInArray( aFlt, 'Day(CreateDate)=' + Str(Day(Today)) );
      AddInArray( aFlt, 'Mon(CreateDate)=' + Str(Mon(Today)) );
      AddInArray( aFlt, 'Year(CreateDate)=' + Str(Year(Today)) );
      Result = FindRecord(– ѕ_—»—.—мена, MakeFilter(aFlt) );
      if (Result = nil) then
        Result = – ѕ_—»—.—мена.Create;
        Result.Ќомер—мены¬√оду = —мен¬√оду + 1;
        Result.Post;
      fi;
    fi;
  end;

  proc ”ст‘орматћаскиѕоиска synonym SetFindMaskFormat (ByField :String; locFindMaskFormats :Cardfile.FindMaskFormats = Cardfile.FindFromBegin);
    var vColumn :CardfileColumn;
    vColumn = Self.Cardfile.ColumnByField[ByField];
    if (vColumn <> nil) then
      vColumn.FindMaskFormat = locFindMaskFormats;
    fi;
  end;

  proc ”далитьЌеключевые—толбцы;
    var i, ii :Integer;
    ii = Self.Cardfile.ColumnsCount;
    for i = ii .. 1 step -1 do
      if not (Self.Cardfile.Column[i].FieldName in »мена лючевых—толбцов) then
        Self.Cardfile.DeleteColumn(i);
      fi;
    od;
  end;

  proc ”становитьќграничениећинЎирины—толбцов;
    var i, ii :Integer;
    ii = Self.Cardfile.ColumnsCount;
    for i = 1 .. ii do
      Self.Cardfile.Column[i].MinWidth = 10;
    od;
  end;

  proc »зменить»конкуќкна;
    Self.Window.Icon.LoadFromFile(BaseInfo.ProjectByName[Self.ClassProject].Folder + 'Attachments\Icons\inbox_document_text.ico');
  end;

end